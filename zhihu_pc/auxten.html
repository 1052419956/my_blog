<html><meta charset="utf-8"><link rel="stylesheet" href="http://z1.zhimg.com/styles/5a8458ed.main.css"><body><div style="width:1000px" class="main receptacle post-view"><div class="entry-content"><h1 style="font-size:25px">快下来，小燕子</h1><hr>2015-05-28T11:22:49+08:00<p><a href="http://zhuanlan.zhihu.com/hasuranimanjutacibcen/20047246" class="internal">讨厌。再进一步我就走人了。诸位赶紧加油，争做最后一根稻草。 - 为了不吃肥肉的满语笔记 - 知乎专栏</a><br></p><p>"我要上吊，你们都别拦着我……"</p><p>叔真是看到你们这样很捉急啊<br></p><p>都好几万粉了，能不能像个“媒体”一样活着</p><p>葛大大走了，知乎还不是这样，大家继续开心的刷着</p><p>那个，最后一句，<a href="https://www.zhihu.com/people/ed446cd9a1168d239774df21e7750c8b" data-hash="ed446cd9a1168d239774df21e7750c8b" class="member_mention" data-tip="p$b$ed446cd9a1168d239774df21e7750c8b">@Hasuran Li</a> 走之前能不能把你的粉丝转让给我？</p></div><div class="entry-content"><h1 style="font-size:25px">漫谈CGI FastCGI WSGI</h1><hr>2015-06-02T17:59:45+08:00<p><b>CGI（Common Gateway Interface）</b><br></p><p>最初，CGI 是在 1993 年由美国国家超级电脑应用中心（NCSA）为 NCSA HTTPd Web 服务器开发的。</p><p>这个 Web 服务器使用了 <b>UNIX shell 环境变量</b> 来保存从 Web 服务器传递出去的参数，然后生成一个运行 CGI 的<b>独立进程</b>。CGI的第一个实现是 Perl 写的[1]。</p><ul><li>效率低下：每一个连接 fork 一个进程处理。</li><li>功能十分有限：CGI只能收到一个请求，输出一个响应。很难在CGI体系去对Web请求的控制，例如：用户认证等。</li></ul><p>正因为这些问题，在CGI诞生后的很长一段时间，各种Web Server都还是采用API这种强绑定的方式去支持Web开发，其中Apache的mod_php就属于这种方式。所以后面就有大神提出了FastCGI标准。</p><p><b>FastCGI（Fast Common Gateway Interface）</b></p><p>FastCGI使用进程/线程池来处理一连串的请求。这些进程/线程由FastCGI服务器管理，而不是Web服务器。 当进来一个请求时，Web服务器把环境变量和这个页面请求通过一个Socket长连接传递给FastCGI进程。所以FastCGI有如下的优点：</p><ul><li>性能：通过进程/线程池规避了CGI开辟新的进程的开销。</li><li>兼容：非常容易改造现有CGI标准的程序。</li><li>语言无关：FastCGI是一套标准，理论上讲只要能进行标准输出（stdout）的语言都可以作为FastCGI标准的Web后端。<br>下面是一个简单FastCGI后端的伪代码<br></li></ul><div class="highlight"><pre><code class="language-text">void main(void)
{
int count = 0;
  while(FCGI_Accept() &gt;= 0) {
    printf(“Content-type: text/html\r\n”);
    printf(“\r\n”);
    printf(“Hello world!\r\n”);
    printf(“Request number %d.”, count++);
  }
exit(0);
}
</code></pre></div><br><ul><li>Web Server隔离：FastCGI后端和Web Server运行在不同的进程中，后端的任何故障不会导致Web Server挂掉。</li><li>专利：没有Apache mod_php之类的私有API的知识产权问题。</li><li>扩展：FastCGI后端和Web Server通过Socket进行通信，两者可以分布式部署并方便进行横向扩展。</li></ul><p>所以FastCGI一推出就几乎获得了所有主流Web Server的支持，Apache、Lighttpd、IIS、Cherokee……</p><p>题主说的php-fpm就是一种FastCGI的后端实现。</p><p>But，事情总是还有改进的余地的，FastCGI这套工作模式实际上没有什么太大缺陷，但是有些不安分的Python程序猿觉得，FastCGI标准下写异步的Web服务还是不太方便，如果能够收到请求后CGI端去处理，处理完毕后通过Callback回调来返回结果，那样岂不是很Coooool？！所以WSGI就被创造出来了：</p><p><b>WSGI（Web Server Gateway Interface）</b></p><p>Web服务器网关接口（Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。</p><p>当Web Server收到一个请求后，可以通过Socket把环境变量和一个Callback回调函数传给后端Web应用，Web应用在完成页面组装后通过Callback把内容返回给Web Server。这样做的优点有很多：</p><ul><li>异步化，通过Callback将Web请求的工作拆解开，可以很方便的在一个线程空间里同时处理多个Web请求。</li><li>方便进行各种负载均衡和请求转发，不会造成后端Web应用阻塞。</li></ul><br><ol><li>Web开发有3P：Perl、Python、PHP。Perl是1987年发布的，Python是1989年，PHP是1995年。CGI标准提出的时候正是Perl如日中天的时候，所以CGI的提出当时也是主要为了解决Perl作为Web编程语言的需求。熟悉正则（regex）的程序员可能知道正则的事实标准叫做pcre（Perl兼容正则表达式，Perl Compatible Regular Expressions），这也从一个侧面体现了Perl作为一个古老的语言在当时对各种业界标准的影响。</li></ol>From：<a href="http://blog.51reboot.com/cgi-fastcgi-wsgi/" class=" wrap external" target="_blank" rel="nofollow noreferrer">漫谈CGI FastCGI WSGI<i class="icon-external"></i></a></div><div class="entry-content"><h1 style="font-size:25px">闲扯网络服务器的安全问题</h1><hr>2015-06-04T13:30:31+08:00<p><b>首先，这是个很大的命题，之前在360负责过几个对外的服务的研发，也算是有点小经验，我试着答一下：</b></p><p>在Internet环境下，安全问题我主要分为如下几类：</p><ol><li>信息传输过程中被黑客窃取</li><li>服务器自身的安全</li><li>服务端数据的安全</li></ol><p>首先，如果能用https，就尽量用https，能用nginx等常见服务器，就用常见服务器，主要能避免以下问题：</p><ul><li>自己实现的协议&amp;Server端可能会有各种Bug，被缓冲区溢出攻击等</li><li>SSL加密体系在防监听方面已经足够成熟，值得信赖</li></ul><p>所幸，私有协议服务的攻击需要黑客分析协议，这就给一般的小服务增加了一层保护。但如果是在大公司做事，树大招风，就必须至少做到理论上没有安全漏洞。神马，xor混淆一下，C/S端写死一个对称密钥这种掩耳盗铃的事情就不要做了，不然会死的很难看。</p><p>如果需要自己实现Server端，实现一套合格的SSL还是很考验功底的：</p><ul><li>首先要弄明白SSL加密体系密钥交换的原理</li><li>对各种对称、非对称加密算法要有深刻的理解</li><li>用非对称加密算法怎么实现一套密钥交换体系</li><li>如何处理ca证书，在自签名情况下怎么避免中间人攻击</li></ul><p>工程实现过程中，要考虑：</p><ul><li>各种可能的缓冲区溢出攻击</li><li>SYN flood攻击，慢连接攻击</li><li>DDoS防起来有难度，但至少能防御DoS攻击</li></ul><p>业务逻辑层面，要考虑：</p><ul><li>每个接口都要做好用户&amp;权限验证</li><li>接口会不会被人乱用，重放攻击</li><li>攻击方会不会找到一个比较消耗服务端资源的接口，用很小的代价耗尽服务端资源</li><li>用户的用户名密码会不会被通过接口破解，参见：<a href="http://en.wikipedia.org/wiki/2014_celebrity_photo_hack" class=" wrap external" target="_blank" rel="nofollow noreferrer">2014 celebrity photo hack<i class="icon-external"></i></a></li><li>你的服务会不会被黑客利用去攻击别的服务，特别是会根据用户输入抓取什么资源的服务</li><li>古老的SQL注入</li><li>无耻的仿冒服务，DNS欺诈</li><li>涉及HTML的，还要考虑跨站……</li></ul><p>即使你做到了天衣无缝，还要考虑队友有时会掉链子：</p><ul><li>glibc、openssl这些基础的库也会爆出漏洞，参见：<a href="http://en.wikipedia.org/wiki/Heartbleed" class=" wrap external" target="_blank" rel="nofollow noreferrer">Heartbleed<i class="icon-external"></i></a></li><li>同一台主机上的其它服务被攻陷</li></ul><p>没有踩过很多坑，哪里知道很多事。写完之后整个人都不好了</p></div><div class="entry-content"><h1 style="font-size:25px">加解密（Encryption）& 哈希（Hash）算法----入门指引</h1><hr>2015-06-09T20:19:10+08:00<p><b>一、Encryption算法和Hash算法的区别</b><br></p><ul><li>信息论角度：</li><ul><li>Encryption是可逆的，没有信息熵的改变</li><li>Hash是不可逆的，Hash一般会导致信息熵减小</li></ul><li>应用角度：</li><ul><li>Encryption常被用来做基于密钥的数据加解密（AES、RSA、ECC）</li><li>Hash主要被用来做数字签名、数据校验（CRC、SHA、MD5）</li></ul><li>小白角度：</li><ul><li>Encryption就是带密码的保险箱</li><li>Hash就是榨汁机，有去无回</li></ul></ul><p><b>二、加解密算法分为对称（Symmetric）、非对称（Asymmetry）两大类</b></p><ul><li>对称（Symmetric）加密<br>
对称加密是最古老的一种加密方式，从最古老的基于查表替换的“凯撒密码”到现代的AES等算法，都是这种类型。其核心特点在于加密、解密的密钥是一样的（或可以互相通过算法变换的）。这种算法很容易理解，就是一把钥匙既能加锁也能开锁。几种常见的对称加密算法：</li><ul><li>凯撒密码</li><ul><li>例如把一本小说里的 a 替换成 b 、b 替换成 c、c 替换成 d，或者根据一个映射表进行替换。详细资料参见 <a href="https://zh.wikipedia.org/zh-cn/%E5%87%B1%E6%92%92%E5%AF%86%E7%A2%BC" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">zh.wikipedia.org/zh-cn/</span><span class="invisible">%E5%87%B1%E6%92%92%E5%AF%86%E7%A2%BC</span><span class="ellipsis"></span><i class="icon-external"></i></a> 。 这种加密方式比较小儿科，根据词频统计就可以轻易破解，常见于小学生传纸条，中学生信息学奥赛。</li></ul><li>AES（Advanced Encryption Standard）</li><ul><li>这个算法久经考验，运算速度在对称加密中能排到前三，参见Crypto++官方的测试 <a href="http://www.cryptopp.com/benchmarks.html%EF%BC%8C%E5%B9%BF%E6%B3%9B%E5%BA%94%E7%94%A8%E4%BA%8E%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86%E8%BD%AF%E4%BB%B6%E3%80%81%E7%A1%AC%E4%BB%B6%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%9A%84block%E5%A4%A7%E5%B0%8F%E6%9C%89128bytes%E3%80%81256bytes%E3%80%82" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://www.cryptopp.com/benchmarks.html<i class="icon-external"></i></a> ，广泛应用于各种加密软件、硬件，常用的block大小有128bytes、256bytes。</li><li><a href="https://zh.wikipedia.org/zh/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">zh.wikipedia.org/zh/%E9</span><span class="invisible">%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86</span><span class="ellipsis"></span><i class="icon-external"></i></a></li></ul><li>SM1、SM4</li><ul><li>SM4是国产加密算法，block大小为128bytes，算法是开源的。SM1现在是有硬件实现。</li><li>关于SM这个名字，我亲身请教过北京市保密局的专家&amp;领导，“SM是算密或者商密的简称。”</li></ul><li>DES、3DES、Blowfish、RC4等</li><ul><li>对称加密的算法非常之多，一般使用中用AES就基本够用了。</li></ul></ul><li>非对称（Asymmetry）加密<br>
非对称加密算法，就是加密、解密的密钥分为两组，并且互相不能反推。这种算法在现实中很难有什么事物可以类比。大致就是通过某种算法可以生成一个密钥对k1、k2，用k1加密之后的密文只能用k2解密，反之亦然。<br>
非对称加密算法从原理上讲常用的有两种：</li><ul><li>基于因数分解的算法</li><ul><li>RSA、DSA是此类算法中的代表，Linux系统的SSH就是基于这两种算法进行文件key auth。前几年一般建议RSA至少要达到1024位密钥才能保证抵御暴力破解，但由于GPU和超级计算机的算力提升，现在密钥长度建议2048位了。</li></ul><li>椭圆曲线算法（ECC）</li><ul><li>这里说的ECC不是服务器内存上用到的Error-Correcting Code（奇偶校验），而是Elliptic Curve Cryptography。内在原理其实我这种搬砖的程序猿不懂，大致是基于解决椭圆曲线离散对数问题的一种算法-_-|||。但我知道的是这个算法可以用1/6的密钥长度达到比RSA更高的强度。代表算法有ECC、SM2等。</li></ul></ul><li>非对称加密算法非常酷，但它有一个致命的缺点：慢。RSA加密的速度大致是AES的1/30左右。所以我们不可能在所有场合都采用这类加密算法。我们的程序猿前辈们就创造了SSL、TLS等加密体系：</li></ul><p><b>三、加密体系</b></p><p>说到要给大家理清几个概念：</p><p><b>TLS的前身是SSL，HTTP + TLS = HTTPS</b></p><blockquote><p>TLS协议允许C/S模型的应用程序跨网络通讯，旨在防止窃听和篡改的方式进行沟通。 TLS协议的优势在于它是与应用层协议独立无关的。高层的应用层协议（例如：HTTP、FTP、Telnet等等）能透明的建立于TLS协议之上。TLS协议在应用层协议通信之前就已经完成加密算法、通信密钥的协商以及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。</p><p>TLS协议是可选的，所以如果需要使用就必须配置客户端和服务器，有两种主要方式实现这一目标：一个是使用统一的TLS协议端口号（例如：用于HTTPS的端口443）；另一个是客户端请求服务器连接到TLS时使用特定的协议机制 （例如：邮件、新闻协议和STARTTLS)。一旦客户端和服务器都同意使用TLS协议，他们通过使用一个握手过程协商出一个有状态的连接以传输数据[1]。通过握手，客户端和服务器协商各种参数用于建立安全连接：</p><p>1. 当客户端连接到支持TLS协议的服务器要求建立安全连接并列出了受支持的密码组合（加密密码算法和加密哈希函数），握手开始。</p><p>2. 服务器从该列表中决定加密和散列函数，并通知客户端。</p><p>3. 服务器发回其数字证书，此证书通常包含服务器的名称、受信任的证书颁发机构（CA）和服务器的公钥。</p><p>4. 客户端确认其颁发的证书的有效性。</p><p>5. 为了生成会话密钥用于安全连接，客户端使用服务器的公钥加密随机生成的密钥，并将其发送到服务器，只有服务器才能使用自己的私钥解密。</p><p>6. 利用随机数，双方生成用于加密和解密的对称密钥。</p><p>7. 这就是 TLS 协议的握手，握手完毕后的连接是安全的，直到连接（被）关闭。如果上述任何一个步骤失败，TLS 握手过程就会失败，并且断开所有的连接。</p></blockquote><p>以上小节摘自：<a href="https://zh.wikipedia.org/zh-cn/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">zh.wikipedia.org/zh-cn/</span><span class="invisible">%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0</span><span class="ellipsis"></span><i class="icon-external"></i></a></p><p><b>四、块（Block）加密 &amp; 流（Stream）加密</b></p><p>世界上的数据分为两种：Block and Stream —— auxten</p><ul><li>Block</li><ul><li>块很容易理解，数据就在那里，无论你读或者不读。块的一个显著特征就是支持“随机读写”，你可以对数据Block正向读、倒着读、跳着读、躺着读。磁盘和内存都是这类数据。大多数加密算法对Block的支持是原生的，也就是说Block是大多数加密算法的加密、解密最小单元。</li></ul><li>Stream</li><ul><li>流就像水管一样，打开水龙头，来什么你就收什么。流的一个显著特征就是<b>不</b>支持“随机读写”。由于解密的过程会对之前的数据有依赖，对流进行加密难度系数要比块加密要高。流的一个典型场景就是网络数据传输，如：HTTPS、SSH等协议。</li></ul></ul><p><b>五、盐的重要性</b></p><p>之前在这篇文章中提到过，如果单纯的把文件按块去加密，即使采用最强壮的算法也会存在一个很明显的漏洞，这里不再赘述，参见：<a href="http://www.zhihu.com/question/22312959/answer/41758072" class="internal">用已知加密算法AES加密文本123，得到密文xxx，问能否根据密文、加密算法、原文本123直接推导出密钥是什么？ - auxten 的回答</a></p><p><b>六、暴力破解（Brute-force）</b></p><ul><li>原理就是穷举密钥去尝试解密，由于GPU的算力提升，量子计算机的兴起，很多算法变得不堪一击。</li></ul><p><b>七、哈希（Hash）</b></p><img src="https://pic4.zhimg.com/fa9f80f4891ed8b3673627a0d20969a3_b.jpg" data-rawwidth="558" data-rawheight="444" class="origin_image zh-lightbox-thumb" width="558" data-original="https://pic4.zhimg.com/fa9f80f4891ed8b3673627a0d20969a3_r.jpg"><br><p>哈希算法在很多地方也被叫做摘要算法、散列算法。简单来说就像是给数据录指纹。常用来做数据校验、数据签名。常见算法有MD5、SHA、CRC等。</p><p>维基百科中英文版的这篇文章写得比较全面<a href="https://en.wikipedia.org/wiki/Hash_function%EF%BC%8C%E6%88%91%E5%B0%B1%E8%A1%A5%E5%85%85%E4%B8%80%E7%82%B9%EF%BC%8C%E5%85%B3%E4%BA%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E7%94%A8%E3%80%82" class=" wrap external" target="_blank" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Hash_function <i class="icon-external"></i></a></p><p>我就补充一点，关于哈希函数的选用：<br></p><p>工作中发现，很多人对哈希函数的了解仅限于MD5。例如，在做数据库的分库分表的时候，可能需要对hostname做一次哈希再去取模，这里采用MD5就显得过于浪费CPU。要知道MD5平均会将每个Byte进行6.8次运算代入。</p><p>如果只是需要利用哈希的离散型，完全可以采用更轻的哈希算法，例如fnv hash，对内存是顺序访问，对CPU cache友好，效率比MD5高出很多。具体参见chongo大神的这篇文章：<a href="http://www.isthe.com/chongo/tech/comp/fnv/" class=" wrap external" target="_blank" rel="nofollow noreferrer">FNV Hash<i class="icon-external"></i></a></p></div><div class="entry-content"><h1 style="font-size:25px">Hudson和Jenkins的恩恩怨怨</h1><hr>2015-06-17T14:09:12+08:00<p>Hudson是在2004年的夏天由Sun公司开发的（就是开发Java的那家），2005年2月开源并发布了第一个版本。<br></p><p>Hudson发布的时候CruiseControl是CI界的老大哥，但是很快，在大约2007年的时候Hudson已经超越CruiseControl。2008年5月的JavaOne大会上，Hudson获得了开发解决方案类的Duke's Choice奖项。从此，小弟翻身做大哥，Hudson成为CI的代名词。</p><p>但平静的日子总是短暂的。2009年6月，乌龟壳（Oracle）收购Sun，所有人都炸裂了：</p><p>是不是写反了？！！！</p><p>一个搞闭源数据库的公司tmd收购了 风暴降生-SPARK之母-不焚者-Java女王-CPU和小型机先民的女王-Solaris的卡丽熙-打碎镣铐者-Sun Microsystem！！！</p><p>乌龟壳公司在开源界的形象一直比M$还差（后面的收购MySQL，虽然继续保持开源，但把test case藏着掖着……这都是Oracle这家公司的所作所为）</p><p>2010年9月，乌龟壳公司偷偷把Hudson®™变成了注册商标。2010年11月，Hudson社区的核心开发人员发现并angry了，双方进行了不太友好的会谈，不出意料的谈崩了。圣诞节过后，2011年的第一场雪，比以往来的要晚一些，几个秃顶的大叔在McDonald‘s的豪华包间里做了一个艰难的决定：</p><div class="highlight"><pre><code class="language-text">mv -f hudson jenkins
</code></pre></div><p>从此王子和公主过上了井水不犯河水的日子。Hudson和Jenkins都拥有代码；</p><ul><li>Hudson有Oracle和Sonatype's corporate的支持和Hudson的注册商标</li><li>Jenkins拥有的是大多数的核心开发者，社区，和后续更多的commit </li></ul><p><img src="https://pic1.zhimg.com/385e48f0787092fa7883e9092acdf804_b.jpg" data-rawwidth="453" data-rawheight="357" class="origin_image zh-lightbox-thumb" width="453" data-original="https://pic1.zhimg.com/385e48f0787092fa7883e9092acdf804_r.jpg">上图，From：<a href="http://daniel.gredler.net/2011/04/04/hudson-and-jenkins-two-months-later/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Hudson and Jenkins: Two Months Later<i class="icon-external"></i></a></p><p>2011年，Jenkins的卡丽熙 Kohsuke Kawaguchi 获得了Google-O'Reilly Open Source Award。2014年Kawaguchi创立了CloudBees，出任CEO，迎娶白富美，走上人生新巅峰。</p><p><b>CloudBees的融资历史：</b></p><p>Year    Amount (USD)    Partners</p><p>2010    $4 million  Matrix Partners, Marc Fleury, Bob Bickel</p><p>2011    $10.5 million   Lightspeed Venture Partners, Matrix Partners</p><p>2014    $11.2 million   Verizon Ventures, Matrix Partners, Lightspeed Venture Partners, BlueCloud Ventures</p><p>2015    $23.5 million   Lightspeed Venture Partners &amp;existing investors Matrix Partners,Verizon Ventures, Blue Cloud Ventures</p></div><div class="entry-content"><h1 style="font-size:25px">1000,000 packets/s的挑战</h1><hr>2015-06-19T18:17:22+08:00How to receive a million packets per second <i>16 Jun 2015 by <a href="https://blog.cloudflare.com/author/marek-majkowski/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Marek Majkowski<i class="icon-external"></i></a>.</i> 翻译：auxten<br>标题图：<a href="https://creativecommons.org/licenses/by-sa/2.0/" class=" wrap external" target="_blank" rel="nofollow noreferrer">CC BY-SA 2.0<i class="icon-external"></i></a><a href="https://www.flickr.com/photos/mccaffrey_uk/3208129302" class=" wrap external" target="_blank" rel="nofollow noreferrer">image<i class="icon-external"></i></a> by <a href="https://www.flickr.com/photos/mccaffrey_uk" class=" wrap external" target="_blank" rel="nofollow noreferrer">Bob McCaffrey<i class="icon-external"></i></a><br><br>之前在360工作，有同事做360安全DNS，和CloudFlare遇到了类似的问题<br>今天看到CF的blog发出了这篇文章，特此翻译一下，原文地址：<a href="https://blog.cloudflare.com/how-to-receive-a-million-packets/" class=" wrap external" target="_blank" rel="nofollow noreferrer">How to receive a million packets per second<i class="icon-external"></i></a><br><br>上周在一次闲聊中，我听一个同事说：“Linux的网络栈实现真是糟透了，单核50k packets/s就是极限了！”
<br>于是我就想了，也许单核50kpps是普通Linux上运行的程序的极限，那么，Linux网络栈的极限是多少呢？所以就引出了我们的问题：<br><blockquote>在Linux环境下实现一个能接收1000k UDP包的程序有多难？</blockquote>我希望解答这个问题，可以给大家上一堂生动的《现代操作系统的网络栈设计》<br><br>首先我们假设：<br><ul><li>测试 packets per second (pps) 比测试 bytes per second(Bps)更有意义。你可以通过pipeline和发送更大的包来达成更高的Bps，提高pps更加有挑战性。</li><li>既然我们关心的是pps，我们将会用UDP消息进行测试。更精确的说：32 bytes的UDP payload，也就是网络层的74 bytes。</li><li>为了测试，我们会用到两台物理机，我们暂且称作：“receiver”和“sender”。</li><li>两台物理机的配置为：2颗6 core 2GHz Xeon处理器，开启了超线程，也就是每台机器有24个逻辑处理器；网卡为Solarflare的10G多队列网卡，开启了11个接收队列，这点我们在后续会展开描述。</li><li>源代码参见这里： <a href="https://github.com/majek/dump/blob/master/how-to-receive-a-million-packets/udpsender.c" class=" wrap external" target="_blank" rel="nofollow noreferrer">dump/udpsender.c at master · majek/dump · GitHub<i class="icon-external"></i></a> , <a href="https://github.com/majek/dump/blob/master/how-to-receive-a-million-packets/udpreceiver1.c" class=" wrap external" target="_blank" rel="nofollow noreferrer">dump/udpreceiver1.c at master · majek/dump · GitHub<i class="icon-external"></i></a>.<br></li></ul><h2>准备工作</h2><br>我们用4321端口作为UDP的端口。在我们开始之前，我们需要确保流量不被 iptables影响：<br><div class="highlight"><pre><code class="language-bash">receiver<span class="nv">$ </span>iptables -I INPUT <span class="m">1</span> -p udp --dport <span class="m">4321</span> -j ACCEPT
 
receiver<span class="nv">$ </span>iptables -t raw -I PREROUTING <span class="m">1</span> -p udp --dport <span class="m">4321</span> -j NOTRACK 
</code></pre></div><p>设定网卡IP</p><br><div class="highlight"><pre><code class="language-bash">receiver<span class="nv">$ </span><span class="k">for</span> i in <span class="sb">`</span>seq <span class="m">1</span> 20<span class="sb">`</span><span class="p">;</span> <span class="k">do</span> <span class="se">\ </span>
              ip addr add 192.168.254.<span class="nv">$i</span>/24 dev eth2<span class="p">;</span> <span class="se">\</span>
          <span class="k">done</span>
sender<span class="nv">$ </span>ip addr add 192.168.254.30/24 dev eth3 
</code></pre></div><br><h2>1. 简单实现版</h2><br>我们先实现一个最简单版本的sender和receiver，看看能抗住多少包<br><p>sender的伪代码如下：</p><br><div class="highlight"><pre><code class="language-c"><span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SOCK_DGRAM</span><span class="p">)</span>
 
<span class="n">fd</span><span class="p">.</span><span class="n">bind</span><span class="p">((</span><span class="s">"0.0.0.0"</span><span class="p">,</span> <span class="mi">65400</span><span class="p">))</span> <span class="err">#</span> <span class="n">select</span> <span class="n">source</span> <span class="n">port</span> <span class="n">to</span> <span class="n">reduce</span> <span class="n">nondeterminism</span> 
<span class="n">fd</span><span class="p">.</span><span class="n">connect</span><span class="p">((</span><span class="s">"192.168.254.1"</span><span class="p">,</span> <span class="mi">4321</span><span class="p">))</span> 
<span class="k">while</span> <span class="nl">True</span><span class="p">:</span> 
    <span class="n">fd</span><span class="p">.</span><span class="n">sendmmsg</span><span class="p">([</span><span class="s">"</span><span class="se">\x00</span><span class="s">"</span> <span class="o">*</span> <span class="mi">32</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
</code></pre></div><br>我们本可以使用最常见的 send 调用，但是它的效率比较低. 内核态和用户态的上下文切换将会是一个很大的我们需要尽量避免的开销。幸运的是最近有一个很好用的系统调用 <a href="http://man7.org/linux/man-pages/man2/sendmmsg.2.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">sendmmsg<i class="icon-external"></i></a>加入了内核。用它我们可以一调用发送很多数据包。这里，我们一次发送1024个数据包。
<br>receiver的伪代码:<br><div class="highlight"><pre><code class="language-c"><span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="p">.</span><span class="n">SOCK_DGRAM</span><span class="p">)</span>
 
<span class="n">fd</span><span class="p">.</span><span class="n">bind</span><span class="p">((</span><span class="s">"0.0.0.0"</span><span class="p">,</span> <span class="mi">4321</span><span class="p">))</span> 
<span class="k">while</span> <span class="nl">True</span><span class="p">:</span> 
    <span class="n">packets</span> <span class="o">=</span> <span class="p">[</span><span class="n">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1024</span>
    <span class="n">fd</span><span class="p">.</span><span class="n">recvmmsg</span><span class="p">(</span><span class="n">packets</span><span class="p">,</span> <span class="n">MSG_WAITFORONE</span><span class="p">)</span>
</code></pre></div><br>类似的，我们用 <a href="http://man7.org/linux/man-pages/man2/recvmmsg.2.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">recvmmsg<i class="icon-external"></i></a> 这个比 recv 更为高效的系统调用。<br><p>实验结果如下：</p><br><div class="highlight"><pre><code class="language-bash">sender<span class="nv">$ </span>./udpsender 192.168.254.1:4321
 
receiver<span class="nv">$ </span>./udpreceiver1 0.0.0.0:4321 
  0.352M pps  10.730MiB /  90.010Mb
  0.284M pps   8.655MiB /  72.603Mb
  0.262M pps   7.991MiB /  67.033Mb
  0.199M pps   6.081MiB /  51.013Mb
  0.195M pps   5.956MiB /  49.966Mb
  0.199M pps   6.060MiB /  50.836Mb
  0.200M pps   6.097MiB /  51.147Mb
  0.197M pps   6.021MiB /  50.509Mb
</code></pre></div><br>最简单的实现能达到197k~350k pps。还算不错。但是这里其实还有一定的变数在里面。由于内核随机的在CPU的核上移动我们的程序。把程序和CPU进行绑定会有帮助：<br><div class="highlight"><pre><code class="language-bash">sender<span class="nv">$ </span>taskset -c <span class="m">1</span> ./udp
sender 192.168.254.1:4321 
receiver<span class="nv">$ </span>taskset -c <span class="m">1</span> ./udpreceiver1 0.0.0.0:4321 
  0.362M pps  11.058MiB /  92.760Mb
  0.374M pps  11.411MiB /  95.723Mb
  0.369M pps  11.252MiB /  94.389Mb
  0.370M pps  11.289MiB /  94.696Mb
  0.365M pps  11.152MiB /  93.552Mb
  0.360M pps  10.971MiB /  92.033Mb
</code></pre></div>从结果中可以看出来，内核将进城绑定在我们制定的CPU核上。这样提高了处理器cache的本地命中率，从而让测试数据更加稳定，这正是我们所期望的。<br><br><h2>2. 发送更多的包</h2><br>虽然370k pps对于一个普通的用户态程序是一个不错的成绩，但这仍然离我们的1M pps相去甚远。为了接受更多的包，首先我们必须发送更多的包。如果我们用两个线程独立去发包：<br><br><div class="highlight"><pre><code class="language-bash">sender<span class="nv">$ </span>taskset -c 1,2 ./udpsender <span class="se">\ </span>
            192.168.254.1:4321 192.168.254.1:4321
receiver<span class="nv">$ </span>taskset -c <span class="m">1</span> ./udpreceiver1 0.0.0.0:4321 
  0.349M pps  10.651MiB /  89.343Mb
  0.354M pps  10.815MiB /  90.724Mb
  0.354M pps  10.806MiB /  90.646Mb
  0.354M pps  10.811MiB /  90.690Mb
</code></pre></div><br>但是接收端的数据没有提升。 ethtool -S 将会展示我们的数据包实际上去了哪里：<br><div class="highlight"><pre><code class="language-text">receiver$ watch 'sudo ethtool -S eth2 |grep rx'
 
     rx_nodesc_drop_cnt:    451.3k/s
     rx-0.rx_packets:     8.0/s
     rx-1.rx_packets:     0.0/s
     rx-2.rx_packets:     0.0/s
     rx-3.rx_packets:     0.5/s
     rx-4.rx_packets:  355.2k/s
     rx-5.rx_packets:     0.0/s
     rx-6.rx_packets:     0.0/s
     rx-7.rx_packets:     0.5/s
     rx-8.rx_packets:     0.0/s
     rx-9.rx_packets:     0.0/s
     rx-10.rx_packets:    0.0/s
</code></pre></div><br>通过这些stats，这个NIC报告在#4的RX queue上成功的发送了350kpps的数据。rx_nodesc_drop_cnt 是一个Solarflare的计数器表示有450kpps的数据在传送给内核的时候失败了。
<br><br>有时候排查这种问题是比较困难的。但是在我们这，原因是很明了的：RX queue #4把包发给了CPU #4。CPU #4已经不能承受更多的工作—读取350kpps的数据包已经让CPU打满。下图是Htop中的展示，红色表示的是sys time，也就是系统调用的CPU时间占比：<br><br><img src="https://pic2.zhimg.com/e7645173da9422cdfc1d6e756dc13ce5_b.jpg" data-rawwidth="366" data-rawheight="365" class="content_image" width="366"><br><br>多队列网卡<br><br>很久以前，网卡都是用单队列在硬件和内核中进行数据包的传输的。这个设计有十分明显的缺陷：如果数据包超过单核的处理能力，那么吞吐量就不能提升了。<br>为了更好的利用多核系统，网卡开始支持多接受队列。多队列的设计是非常简单的：每一个RX queue都被绑定到一个单独的CPU，这样，通过把数据包分散在多个RX queue就可以利用上多CPU的处理能力。但是这也带来一个问题：对于一个数据包，如何决定由哪个RX queue去处理？<br><img src="https://pic1.zhimg.com/c9adf8a9a09a5a99a8a0af0707ac9cfc_b.jpg" data-rawwidth="1850" data-rawheight="704" class="origin_image zh-lightbox-thumb" width="1850" data-original="https://pic1.zhimg.com/c9adf8a9a09a5a99a8a0af0707ac9cfc_r.jpg"><br><br>Round-robin轮询是不可接受的，因为这样会导致在同一个连接的数据包乱序。所以一个替代方案就是利用基于数据包的哈希来决定RX queue。哈希的输入一般是IP四元组（源IP、目的IP、源端口、目的端口）。这就确保了一个在一个连接上的数据包始终保持在一个RX queue，这样也就杜绝了数据包的乱序。<br><br>用伪代码表示：<br><div class="highlight"><pre><code class="language-python"><span class="n">RX_queue_number</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="s">'192.168.254.30'</span><span class="p">,</span> <span class="s">'192.168.254.1'</span><span class="p">,</span> <span class="mi">65400</span><span class="p">,</span> <span class="mi">4321</span><span class="p">)</span> <span class="o">%</span> <span class="n">number_of_queues</span>  
</code></pre></div><br>多队列哈希算法<br>我们可以用 ethtool来配置多队列哈希算法。我们的配置步骤如下：<br><br><div class="highlight"><pre><code class="language-bash">receiver<span class="nv">$ </span>ethtool -n eth2 rx-flow-hash udp4
 
UDP over IPV4 flows use these fields <span class="k">for</span> computing Hash flow key: 
IP SA 
IP DA 
</code></pre></div><br>这便是对于IPv4的UDP数据包，网卡将会对 源IP、目的IP进行哈希，例如：<br><div class="highlight"><pre><code class="language-text">RX_queue_number = hash('192.168.254.30', '192.168.254.1') % number_of_queues  
</code></pre></div><br>这个是相当有局限性的一种算法。许多网卡可以自定义哈希算法。所以我们可以用ethtool 把哈希算法的输入改成 源IP、目的IP、源端口、目的端口:<br><div class="highlight"><pre><code class="language-bash">receiver<span class="nv">$ </span>ethtool -N eth2 rx-flow-hash udp4 sdfn
 
Cannot change RX network flow hashing options: Operation not supported 
</code></pre></div><br>But，不幸的是，我们的网卡不支持这种模式，所以我们这里只能采用对源IP、目的IP进行哈希的算法。<br><br>NUMA对于性能的影响<br><br>目前为止，我们的数据包只使用了一个RX queue和一个CPU。我们正好利用这次机会讨论一下NUMA对于性能的影响。在我们的receiver主机上有两组独立的CPU，每一组都属于一个独立的 <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access" class=" wrap external" target="_blank" rel="nofollow noreferrer">NUMA node<i class="icon-external"></i></a><a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access" class=" wrap external" target="_blank" rel="nofollow noreferrer">Non-uniform memory access<i class="icon-external"></i></a>.
<br><br>我们可以把我们的单线程receiver绑定到4个我们感兴趣的CPU中的一个。4个选项如下：<br><ol><li>把receiver运行在和RX queue同一个NUMA node，但是不同的CPU上。我们观测到的性能大概是 360kpps。<br><br></li><li>把receiver运行在和RX queue同一个CPU上，我们可以得到 430kpps的性能峰值。但是波动很大。当网卡被数据包打满的时候性能会跌到0。<br><br></li><li>把receiver运行在处理RX queue的CPU的HT对应的逻辑核上，性能会是平时性能的一半左右：200kpps。<br></li><li>把receiver运行在和处理RX queue不同的NUMA node上，性能大概是 330kpps，但是数值不太稳定。<br><br></li></ol>这么看来，运行在不同NUMA node上带来的10%的性能损失不是很大，损失似乎是成比例的。在某些试验中，我们只能从每个核上压榨出 250kpps的性能极限。跨NUMA node带来的性能影响只有在更高的吞吐量的情况下才会变得更加明显。在某一次测试中我们把receiver运行在一个比较差的NUMA node上，性能损失了4倍左右。<br><h2>3. 多个接受端IP</h2><br>由于我们的网卡的哈希算法非常局限，想要把数据包分布到多个RX queue上的唯一方法就是使用多个IP地址。下面就是我们实际操作的方法：<br><br><div class="highlight"><pre><code class="language-bash">sender<span class="nv">$ </span>taskset -c 1,2 ./udpsender 192.168.254.1:4321 192.168.254.2:4321 
</code></pre></div><br>ethtool 可以用来查看各个RX queue的状态<br><div class="highlight"><pre><code class="language-bash">receiver<span class="nv">$ </span>watch <span class="s1">'sudo ethtool -S eth2 |grep rx'</span>
 
     rx-0.rx_packets:     8.0/s
     rx-1.rx_packets:     0.0/s
     rx-2.rx_packets:     0.0/s
     rx-3.rx_packets:  355.2k/s
     rx-4.rx_packets:     0.5/s
     rx-5.rx_packets:  297.0k/s
     rx-6.rx_packets:     0.0/s
     rx-7.rx_packets:     0.5/s
     rx-8.rx_packets:     0.0/s
     rx-9.rx_packets:     0.0/s
     rx-10.rx_packets:    0.0/s
</code></pre></div><br><p>接收端的情况：</p><br><div class="highlight"><pre><code class="language-bash">receiver<span class="nv">$ </span>taskset -c <span class="m">1</span> ./udpreceiver1 0.0.0.0:4321
 
  0.609M pps  18.599MiB / 156.019Mb
  0.657M pps  20.039MiB / 168.102Mb
  0.649M pps  19.803MiB / 166.120Mb
</code></pre></div><br>哈哈！用两个核去处理多个RX queue，用第三个去运行我们的receiver，我们可以达到 ~650kpps！<br>我们可以简单地通过把数据发送给3个、甚至4个RX queue去增加吞吐量，但是很快我们就会触碰到另外一个瓶颈。这个时候的表现是rx_nodesc_drop_cnt 不再提升，但是 netstat 的"receiver errors”在增加:
<br><br><div class="highlight"><pre><code class="language-bash">receiver<span class="nv">$ </span>watch <span class="s1">'netstat -s --udp'</span>
 
Udp: 
      437.0k/s packets received
        0.0/s packets to unknown port received.
      386.9k/s packet receive errors
        0.0/s packets sent
    RcvbufErrors:  123.8k/s
    SndbufErrors: 0
    InCsumErrors: 0
</code></pre></div><br>这就表明，网卡可以把数据持续不断的发送给内核，但是内核没能把所有数据包发送给receiver程序。在我们的场景下，内核只能把 440kpps的数据包发送成功，剩下的 390kpps + 123kpps 就被丢弃了，原因在于receiver没有足够的快的接受速度。<br><h2>4. 多线程receiver</h2><br>我们需要扩展我们的receiver。我们最原始的实现，在多线程情况下工作的不理想：<br><div class="highlight"><pre><code class="language-bash">sender<span class="nv">$ </span>taskset -c 1,2 ./udpsender 192.168.254.1:4321 192.168.254.2:4321 
receiver<span class="nv">$ </span>taskset -c 1,2 ./udpreceiver1 0.0.0.0:4321 <span class="m">2</span> 
  0.495M pps  15.108MiB / 126.733Mb
  0.480M pps  14.636MiB / 122.775Mb
  0.461M pps  14.071MiB / 118.038Mb
  0.486M pps  14.820MiB / 124.322Mb
</code></pre></div><br>和单线程的receiver相比，我们的多线程版反而有所下降。这其中的原因在于，在UDP接受缓存上有锁的争抢。两个线程在使用同一个socket文件描述符，它们都花费了相当大比例的时间在激烈争抢UDP接收缓存的锁上。这篇论文更详细的描述了这类问题的细节：<a href="http://www.jcc2014.ucm.cl/jornadas/WORKSHOP/WSDP%202014/WSDP-4.pdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://www.</span><span class="visible">jcc2014.ucm.cl/jornadas</span><span class="invisible">/WORKSHOP/WSDP%202014/WSDP-4.pdf</span><span class="ellipsis"></span><i class="icon-external"></i></a> 。
<br><br>在多线程中使用一个文件描述符去接收数据是很糟糕的实现方式。<br><br><h2>5. SO_REUSEPORT</h2><br>幸好，现在针对这个问题有了一个解决方案：<a href="https://lwn.net/Articles/542629/" class=" wrap external" target="_blank" rel="nofollow noreferrer">The SO_REUSEPORT socket option [LWN.net]<i class="icon-external"></i></a> 。当SO_REUSEPORT这个flag在socket上被标记打开，Linux将会允许多个进程同事绑定在同一个端口上。所以我们可以启动任意数量的进程绑定在同一个端口上，这样这个端口的负载将会在它们之间得到均衡。（译者注：其实没有原作者说的这么复杂，bind、listen完fork就可以实现类似效果，nginx上早就用滥了）
<br><br>在 SO_REUSEPORT 的帮助下每个进程将会有自己独立的socket文件描述符。这样，它们就会有自己独立的UDP接收缓存。这就避免了我们之前遇到的抢锁的问题。<br><div class="highlight"><pre><code class="language-bash">receiver<span class="nv">$ </span>taskset -c 1,2,3,4 ./udpreceiver1 0.0.0.0:4321 <span class="m">4</span> 1
 
  1.114M pps  34.007MiB / 285.271Mb
  1.147M pps  34.990MiB / 293.518Mb
  1.126M pps  34.374MiB / 288.354Mb
</code></pre></div><p>这就对了，现在的吞吐量总算像回事了。</p><br>其实做到这里，我们的程序还是有进一步的提升空间的。如下图所示，四个线程的负载并不均衡：<br><img src="https://pic1.zhimg.com/9664f2d58ed4d5089367e4aea1c00218_b.jpg" data-rawwidth="647" data-rawheight="82" class="origin_image zh-lightbox-thumb" width="647" data-original="https://pic1.zhimg.com/9664f2d58ed4d5089367e4aea1c00218_r.jpg"><br>两个线程把所有的包处理了，另外两个线程没有收到任何的数据包。这里的原因在于“哈希碰撞”，但这次是 SO_REUSEPORT 这个层面导致的。
<br><h2>后记</h2><br>我做了进一步的测试，在RX queue和receiver线程完美对齐在同一个NUMA node的情况下，我们可以达成 1.4Mpps的吞吐量，把receiver运行在不同的NUMA node上最好成绩会下滑到 1Mpps。<br><br>总结一下，如果你想达到完美的性能表现，需要做的事情有：<br><ul><li>确保流量平均分布在多个RX queue上，在每个进程上启用SO_REUSEPORT。在实践中，由于连接数会非常的多，负载一般都会较为均衡的分布在多个进程上。<br><br></li><li>需要有足够的CPU资源从内核中读取数据包。<br><br></li><li>为了达到更高的吞吐，RX queue和receiver需要在同一个NUMA node上。<br><br></li></ul>由于我们上面做的都是技术探索，接受的进程甚至连接受的数据包“看都没看一眼”，这样才在一台Linux机器上能达成1Mpps的成绩。在实际的程序中由于有很多额外的逻辑要做，所以不要指望能达到这个性能。</div><div class="entry-content"><h1 style="font-size:25px">送你一个包子</h1><hr>2015-06-24T17:22:42+08:00来北京第一个十一月，一个人在保利剧院看赖声川／王伟忠的《宝岛一村》，散场时剧组很贴心地发了一袋热腾腾的庆丰包子。为什么说贴心呢？北京的秋天风很大，而散场的时间又很晚，这时候一对对恋人互相拥抱取暖的行为，显然对单身狗造成了萧瑟秋风和秀恩爱的双重加成伤害。而包子既能让你在萧瑟的风中揣着感受温暖，又能让秀恩爱的情侣拥抱起来不那么方便。贴不贴心？<br><br>    飞速地把印有《宝岛一村》剧名的照片发给好友，我想给他说的是，“你看我生活多精彩”，但实际上我说给自己听的是，“这难堪的孤单”<br><br>    北京是一个陌生味很浓的城市。初到北京一直会有一股强烈的孤寂感，具体的表现是周末不知道玩什么，去哪里玩，以及最重要的，和谁玩。好在随着时间增长，慢慢也会发现很多很好玩的地方，看大片儿可以去华星UME，离家近设备也不错；看老电影可以去文慧园路三号，时不时会放些经典电影；看话剧可以去的人艺，保利等各种剧院；吃喝的地方更是难以胜数。<br><br>    好像北京这个地方早已预见了你的孤单，准备好各种五光十色的消遣方式供你选择。但你知道“玩什么”和“去哪里玩”又有什么用？还是无法解决最重要的问题：“和谁玩？”。<br><br>    形容一个人初到一个地方经常会用的一个成语是“人生地疏”，地疏当然是指对这个城市很陌生，不知道去哪里和玩什么。而“人生”自然是指朋友没多少。对于刚来北京的我来说，这十分贴切。<br><br>    随着时间推移，在北京的朋友也逐渐多了起来，师兄师弟同学同事，逐渐也有了自己的“圈子”。但是仍然存在不方便的情况：主动约吧，别人可能没空，被拒绝多尴尬；等别人来约吧，也不知道有没有人约，以及谁会来约；思前想后最后还是选择了宅在家。好不容易有的周末时间又浪费了。<br><br>    然而时间就这么一点一点流逝殆尽，连落款年月都还没有完全习惯写2015，今年都已过了一半。毕竟“花有重开日，人无再少年”。<br><br>    多年以后，做“<b><a href="http://duanzigou.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">谁有空<i class="icon-external"></i></a></b>”这个产品，不可避免地想起了《宝岛一村》散场时那温暖的包子。</div><div class="entry-content"><h1 style="font-size:25px">应用层协议那些事</h1><hr>2015-06-24T19:28:59+08:00<p>应用层的协议简单来说就是程序之间网络通信的方式，相当于就是我们说话的方式，两个人能成功的进行沟通需要有两个先决条件：</p><p><b>1. 大家在说同一种语言</b></p><p>一个只会说汉语的人和一个只会说德语的人注定是无法在一起的；一个胡建人和一个河北人虽然会有较高的误码率，但基本还是可以谈恋爱的。</p><p><b>2. 需要有“断句”方式的约定</b></p><p>人类的沟通无一例外是通过“说话的停顿”和“对于语言内容的理解”来进行断句的：</p><ul><li>说话的停顿</li><ul><li>“Hey，你在干啥呢？”、“写作业呢”、“吃饭了没”、”一会儿去吃煎饼“，理解没有问题</li></ul><li>对于语言内容的理解</li><ul><li>“Hey你在干啥呢吃饭了没”、”写作业呢一会儿去吃煎饼“。也能费劲理解（NLP）</li></ul></ul><p><b>3. 对于计算机网络</b></p><p>当两台计算机需要沟通的时候，情况是十分类似的：</p><p><b>“大家在说同一种语言”</b>很容易理解，我们不能用FTP协议去访问HTTP的服务器。</p><p><b>“断句方式“</b>往往被初学者所忽略，校园招聘的时候经常遇到小朋友做了个“基于socket的文件传输工具”，但细问起传输协议是怎么判定文件传输结束的时候，有很多人就不明白这个问题的点在哪里，这时我就十分怀疑这个”传输工具“只是个Broken Toy。</p><p>由于现在广泛应用的TCP协议是基于流的传输协议（Stream）。也就是说，传输层协议本身没有“断句”的功能。参见：<a href="https://en.wikipedia.org/wiki/Transport_layer#COMPARISON1%E3%80%82%E8%BF%99%E5%B0%B1%E8%A6%81%E6%B1%82%E6%88%91%E4%BB%AC%E5%9C%A8%E5%8D%8F%E8%AE%AE%E5%B1%82%E5%AE%9E%E7%8E%B0%E2%80%9D%E6%96%AD%E5%8F%A5%E2%80%9C%EF%BC%9A" class=" wrap external" target="_blank" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Transport_layer#COMPARISON1<i class="icon-external"></i></a></p><p>这就要求我们在协议层实现”断句“：<br></p><p><b>4. ”断句“的方式</b></p><p>断句的方式也是随着计算机网络的发展一直在进化：</p><ol><li>初，盘古开天辟地，有些类似于PING-PONG协议的非常简单的定长协议，限定消息长度是4个字节，协议的功能也十分之弱智，你发PING，我回PONG。</li><li>1968~1971年诞生的Telnet、FTP这类化石级的协议，一般采用的策略就是和我们写文章一样的方式：用回车和换行来标示一条命令的结束。这里细心的人就会想那遇到消息里本身有\r\n的情况怎么办呢？答案就是，转义！就是在消息本身带有\r\n的地方前面加一个”\”字符。stupid but work</li><li>1982年制定的SMTP协议的Header就沿用了上述的\r\n方式，但SMTP需要传输邮件内容，邮件附件。如果继续采用“转义”大法，恐怕有点吃不消。这时候就有大神提出了用Base64 <a href="https://en.wikipedia.org/wiki/Base64" class=" wrap external" target="_blank" rel="nofollow noreferrer">Base64<i class="icon-external"></i></a> 进行编码，把所有字符都转化成a-z, A-Z, 0-9等字符。这样就就完美解决了这个问题。但副作用就是数据会膨胀1/3左右。<img src="https://pic4.zhimg.com/2d870492d62e085a65d85da3162c2a6b_b.jpg" data-rawwidth="320" data-rawheight="340" class="content_image" width="320"></li><br><li>1991年制定HTTP协议Header继续沿用\r\n的方式，但由于HTTP将会传输更多的数据，用Base64就太浪费宝贵的带宽资源了。于是我们的前辈们就想出一个好办法，在Header里固定增加一个Content-length字段，用来标示，后续的数据大小。Haeder和content用\r\n\r\n分割。这样就解决了问题，有不会造成数据膨胀。（后续增加的trunk模式这里就不展开说了）<br></li><li>当然有朋友就会问了，有没有可能不增加额外的字节解决“断句”问题？答案是：Yes。1999年XMPP协议被制定出来的时候，就实现了这个设想。XMPP是基于XML的协议，XML的语法解析是有能力判断XML是否闭合，从而完成“断句”。但这种方式有一个较为严重的问题就是，“断句”逻辑依赖编码方式，这样在工程上的实现难度就会变大。</li></ol><br><img src="https://pic1.zhimg.com/a88bc796654f3b8f83240e9fa275d1c4_b.jpg" data-rawwidth="1346" data-rawheight="688" class="origin_image zh-lightbox-thumb" width="1346" data-original="https://pic1.zhimg.com/a88bc796654f3b8f83240e9fa275d1c4_r.jpg"><p>这里有个有意思的插曲，大家可能发现GFW有封SSH协议的能力，按理说SSH是加密的，不应该能被识别出来啊，看下图大家就应该明白了：</p><p><img src="https://pic1.zhimg.com/1ce8b8136f75f2a71c5ad894ada62f30_b.jpg" data-rawwidth="626" data-rawheight="284" class="origin_image zh-lightbox-thumb" width="626" data-original="https://pic1.zhimg.com/1ce8b8136f75f2a71c5ad894ada62f30_r.jpg">SSH协议在client连接成功后，server端会主动明文发送ssh的版本信息。</p><p><b>5. 复杂度和效率的平衡</b></p><p>首先我们介绍一种叫Netstring <a href="https://en.wikipedia.org/wiki/Netstring" class=" wrap external" target="_blank" rel="nofollow noreferrer">Netstring<i class="icon-external"></i></a> 的协议：开头用ASCII明文标记后面数据的大小，然后紧跟一个“:”，然后是数据，最后以一个“,”结尾。</p><div class="highlight"><pre><code class="language-bash">12:hello world!,
</code></pre></div><p>空消息：</p><div class="highlight"><pre><code class="language-bash">0:,
</code></pre></div><p>我们在之前几家公司做项目的时候为了平衡“工程实现复杂度”和“运行效率”，往往采用类似Netstring的协议，并进一步简化，固定10bytes的ASCII头表示消息长度，后面紧跟数据。</p><div class="highlight"><pre><code class="language-bash">0000000002hi
</code></pre></div><p>这样做的优势有：</p><ul><li>ASCII头方便debug</li><li>10bytes固定头长度，易于算法实现，消息长度上限大约是10GB，基本够用</li><li>头后面紧跟数据，不需要其它逻辑</li></ul><br><p>应朋友请求打个广告</p><p>欢迎加入Reboot运维&amp;开发技术交流群：365534424</p></div><div class="entry-content"><h1 style="font-size:25px">C 语言进阶有哪些优秀的代码可以阅读？</h1><hr>2015-07-06T15:02:53+08:00之前回答过一个问题，意外的被很多人收藏：<a href="http://www.zhihu.com/question/19880598/answer/30448002" class="internal">C 语言进阶有哪些优秀的代码可以阅读？ - auxten 的回答</a>，现在又补充了一些内容，希望对大家有用。<p><br>网络编程：<br></p><ul><li>redis是单线程异步网络编程的范例</li><li>nginx是多进程网络编程的巅峰，模块化</li><li>memcached虽然是C++，但是C style的，多线程网络编程的巅峰</li></ul><p>数据结构&amp;数据库：</p><ul><li>SQLite，数据理论的范例。注意要去读非合并源文件版的（为了方便编译器优化，有个单文件版的）</li></ul><p>大杂烩类型：</p><ul><li><a href="http://www.gnu.org/software/coreutils/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Coreutils - GNU core utilities<i class="icon-external"></i></a>，大多数Linux系统命令的实现</li><li>Python源代码（CPython，注意不是Cython），多少次遇到百思不得其解的问题，我都是去看看Python是怎么封装成简单可靠的接口的，比如我回答的<a class=" wrap external" href="http://stackoverflow.com/questions/7089128/linux-tcp-connect-with-select-fails-at-testserver/7220380#7220380" target="_blank" rel="nofollow noreferrer">Linux TCP connect with Select() fails at testserver<i class="icon-external"></i></a>，还有怎么实现一个可靠的带自定义超时的connect()，你都可以从Python源码里找到答案。</li><li>Varnish，大名鼎鼎的Varnish缓存服务器，每个线程处理一个连接的架构。但这货的配置文件处理方面做的很优秀，想要研究DSL的同学可以看一下。 <br></li><li>vixie-cron，我们常用的crond。pipe的使用非常的精妙，完美的示范了“如何巧妙的异步非阻塞处理多进程输出”。</li></ul><p>找虐：</p><ul><li><a class=" wrap external" href="http://bird.network.cz/" target="_blank" rel="nofollow noreferrer">The BIRD Internet Routing Daemon Project，宏玩得飞起<i class="icon-external"></i></a></li><li>Kernel，很容易挫伤初学者积极性</li><li>glibc、ssh，这类程序都是上个世纪的大神们的作品，从编程风格和整体架构上都属于晦涩难懂的，代码风格也是现代编程所不推荐的，建议初学者远离。</li></ul></div><div class="entry-content"><h1 style="font-size:25px">Airbnb当时被投资人拒绝的时候的理由</h1><hr>2015-07-13T12:02:59+08:00From：<a href="https://medium.com/@bchesky/7-rejections-7d894cbaa084" class=" wrap external" target="_blank" rel="nofollow noreferrer">7 Rejections<i class="icon-external"></i></a><h3><a class=" wrap external" href="https://medium.com/@bchesky" target="_blank" rel="nofollow noreferrer">Brian Chesky<i class="icon-external"></i></a></h3><p>Co-founder, CEO of Airbnb</p><br><p>Airbnb当时被投资人拒绝的时候的理由<br></p><img src="https://pic3.zhimg.com/5a9c54c4c08efbb357afea35ca8d36de_b.jpg" data-rawwidth="561" data-rawheight="205" class="origin_image zh-lightbox-thumb" width="561" data-original="https://pic3.zhimg.com/5a9c54c4c08efbb357afea35ca8d36de_r.jpg"><img src="https://pic2.zhimg.com/50dd08e8357837b6d5ba0f9c4654174d_b.jpg" data-rawwidth="574" data-rawheight="231" class="origin_image zh-lightbox-thumb" width="574" data-original="https://pic2.zhimg.com/50dd08e8357837b6d5ba0f9c4654174d_r.jpg"><img src="https://pic2.zhimg.com/01af49d340e157bfde153a322ff2bde1_b.jpg" data-rawwidth="585" data-rawheight="201" class="origin_image zh-lightbox-thumb" width="585" data-original="https://pic2.zhimg.com/01af49d340e157bfde153a322ff2bde1_r.jpg"><img src="https://pic2.zhimg.com/8f682ae547be66f3231215de625598b5_b.jpg" data-rawwidth="564" data-rawheight="174" class="origin_image zh-lightbox-thumb" width="564" data-original="https://pic2.zhimg.com/8f682ae547be66f3231215de625598b5_r.jpg"><img src="https://pic4.zhimg.com/46ab454339a59bb31e5f18729d0cc73f_b.jpg" data-rawwidth="583" data-rawheight="125" class="origin_image zh-lightbox-thumb" width="583" data-original="https://pic4.zhimg.com/46ab454339a59bb31e5f18729d0cc73f_r.jpg"></div><div class="entry-content"><h1 style="font-size:25px">Python编程（一）：Python中tuple和list的一点思考</h1><hr>2015-07-14T15:19:20+08:00<p>Python有两种相似的序列类型，tuple和list。 这两者的不同大多数人都能说出：</p><ul><li>tuple叫做元组用()表示；list叫做列表用[]表示。</li><li>tuple是不可变的，list是可变的。</li></ul><p>可能是由于上面说的这两点都是Python解释器强制限制的，所以大家都耳熟能详。有一些有趣的区别往往不被人注意： 严谨来讲，tuple存储的一般是结构化的数据，每一个字段的意义一般是不同的； 而list存储的一般是同类型的顺序数据。 这样说可能有些抽象，我们举个例子:</p><p>一：</p><div class="highlight"><pre><code class="language-python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">time</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">()</span>
<span class="p">(</span><span class="mi">2008</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div><p>第一种time.localtime()返回的类型，是tuple。就像我们上面所说的，这个tuple的第一个位置一定是“年”。 也就是说，这里的tuple就被当作一个轻量级的结构体来使用了。</p><br><p>二：</p><div class="highlight"><pre><code class="language-python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</code></pre></div><p>第二种是一个典型的list，里面的元素虽然我们也是关注其位置和顺序的，但每个元素都是同样的类型，同样的“功能”。</p></div><div class="entry-content"><h1 style="font-size:25px">Amazon ECS 的幕后</h1><hr>2015-07-28T11:04:42+08:00原文作者是Amazon的CTO，Werner Vogels，原文见：<a href="http://www.allthingsdistributed.com/2015/07/under-the-hood-of-the-amazon-ec2-container-service.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://www.</span><span class="visible">allthingsdistributed.com</span><span class="invisible">/2015/07/under-the-hood-of-the-amazon-ec2-container-service.html</span><span class="ellipsis"></span><i class="icon-external"></i></a><p>禁止任何形式的转载，不惜诉诸法律<br><br>在我之前关于Amazon EC2 Container Service（Amazon ECS）的文章中，我论述了在一个集群中部署现代化的分布式程序的两个关键点：依赖状态管理和可伸缩的调度。Amazon ECS让程序在容器中构建和运行更为的方便，但是这里面更有趣的是我们是如何在Amazon ECS中实现这一切的。今天我将会带大家探索一下Amazon ECS的架构以及架构之上的事情。下面的图是Amazon ECS的一个基础架构图：<br><br><img src="https://pic1.zhimg.com/ccd23f3920db91fe497f4d529a75f8c0_b.jpg" data-rawwidth="650" data-rawheight="366" class="origin_image zh-lightbox-thumb" width="650" data-original="https://pic1.zhimg.com/ccd23f3920db91fe497f4d529a75f8c0_r.jpg"><br><br><strong>我们是怎样协调集群的</strong><br><br>我们来讨论一下Amazon ECS实际上是怎么运作的。Amazon ECS的核心是一个集群管理系统，以一个后端服务存在并处理状态管理和集群协调的诸多任务。在集群管理系统上面运行着很多的调度器。集群管理系统和容器调度器是两个完全解耦的模块，允许用户构建并使用自己的调度器。每个集群都是一个供用户程序使用的计算资源池。这里说的资源池就是用容器分割的Amazon EC2的CPU、内存、网络资源的实例。Amazon ECS通过运行在每个EC2实例上的Amazon ECS Container Agent来协调。我们的agent允许Amazon ECS按照用户或者调度器的请求与集群中的EC2实例进行通信去执行start、stop或者监控容器。我们的agent是Go写的，只有很小的开销，已经遵守Apache license开源在了github上。我们欢迎大家贡献代码，各种反馈也是极好的。<br><br><strong>我们是怎么管理状态的</strong><br><br>为了协调集群的正常运作，我们需要确保集群的信息有一个唯一的信息源，信息包括：集群中的EC2实例、EC2实例上运行的任务、承载任务的容器、可以使用的资源（例如，网络端口、内存、CPU等等）。如果不能确切的知晓集群的状态，我们是没有办法成功地启停容器。为了达到这一点，状态信息需要被存储在某个地方，所以所有现代化的集群控制系统的核心都是一个KV存储器。<br><br>我们所有的关于集群的信息（状态，以及所有状态的改变）都是存储在KV存储器中的，KV存储扮演着集群所有信息的唯一数据源的角色。为了在网络分区或者硬件故障的情况下保证健壮新和伸缩性，我们的KV存储器需要用分布式来实现持久化和高可用。但也正是因为我们的KV存储器是分布式的，也使得数据持久化和处理并发的变更更加的困难，特别是在我们这种状态变化频繁的场景下（例如：容器的启动与停止）。所以，并发控制就需要被引入到我们的系统里，去解决大量的状态变更不会冲突。例如，当两个开发者都声称要占用某一个EC2实例的所有可用内存的时候，必须只能有一个请求被满足，另一个请求被告知请求无法满足。<br><br>为了达到并发控制，我们用Amazon的核心分布式基础组件构建了Amazon ECS：一个基于事务日志的Paxos协议实现的数据存储器，负责记录每一次数据条目的变更。任何对数据的写操作都将被赋予一个特定的基于顺序的ID，被当做一次事务日志提交。数据的当前值都是在日志中记录的事务的按顺序叠加的结果。每次数据的读取都是读取的数据最新版本的快照。如果一个写请求想要成功，那么它必须是上一次读取之后最近的一次事务提交。这项特性就使得Amazon ECS可以使用乐观并发来存储集群状态信息，这种设计在共享的持续变化的数据场景下表现优异（例如，呈现像Amazon ECS一样一个共享的计算资源池的状态）。这种架构支撑着Amazon ECS保持高可用、低延迟和高吞吐，这一切都直接受益于数据存储从来不会出现悲观锁。 
<br><br><strong>通过API访问</strong><br><br>由于上述KV存储器的存在，我们可以成功的协调集群的运作也可以保证预期中数量的容器正常运行也正是因为我们可靠的存储和读取集群状态信息的机制。就像我们上面所说的，我们希望我们的用户能利用到Amazon ECS灵活的状态控制能力，所以把容器调度和集群控制进行了解耦。我们开放了一组Amazon ECS集群管理的API，用户通过它能够获取到结构化存储在KV存储器的集群状态信息。<br><br>通过一个简单的‘list’命令，我们的用户可以获取所有管理下的集群，所有运行在特定集群的EC2示例，运行中的任务以及组成任务必不可少的容器配置。通过‘describe’命令，用户可以获取特定EC2示例的详细信息以及它上面的可用资源信息。最近，我们完成了新的功能，用户可以在集群的任何机器上启停任务。我们最近在Amazon ECS上也完成了一系列的压力测试，我们可以分享一下用户在Amazon ECS上构建应用的时候可能比较关注的性能指标。<br><img src="https://pic2.zhimg.com/cfe6d19b86e4ac67775abec96317b2e5_b.jpg" data-rawwidth="650" data-rawheight="386" class="origin_image zh-lightbox-thumb" width="650" data-original="https://pic2.zhimg.com/cfe6d19b86e4ac67775abec96317b2e5_r.jpg"><br>上面的图展示的是，我们在一个经常增加和移除实例的Amazon ECS集群上测试‘DescribeTask’这个API长达72小时的结果，红线和绿线分别是50%峰值和99%峰值。正如图中所示，接口的响应速度在集群规模发生巨大变化的时候几乎没有任何波动。Amazon ECS能做到无聊集群多大都可以保持伸缩性——这一切都不需要用户的操作或者增加集群控制器的规模。<br><br>我们的API动作涵盖了用户在Amazon ECS上构建应用所需的所有动作。用户自定义的调度器只用定义“how”、“when”、“where”去启动和停止容器。Amazon ECS的架构被设计成共享集群的运行状态，并且允许用户运行应用所需的多种多样的调度器（例如：二进制打包、分发、等等）。也正是先进的架构，使得调度器可以查询集群的确切状态，并且把集群作为一个通用的资源池来分配资源。乐观并发控制使得每个调度器可以在请求资源的时候避免可能的资源冲突。我们的用户已经在Amazon ECS上构建了很多有趣的解决方案，我们也希望把一些比较有代表性的分享给大家。<br><br><strong>Hailo – 一个构建在弹性资源池之上的调度器</strong><br><br><a href="https://www.hailoapp.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Hailo<i class="icon-external"></i></a>是一个免费的智能手机应用, 允许用户直接呼叫注册过的出租车到他们的地点。Hailo的全球网络拥有60000个注册的司机和超过1百万的乘客。Hailo在2011年的建立之初就是构建在AWS上的。在过去的几年中，Hailo从一个单独的巨大的运行在一个AWS区域内的程序逐渐进化成微型服务构成的运行在多个AWS区域的架构。之前每个微型服务都是运行在静态划分的一个集群的某个实例上的。这个架构没有很好的伸缩性，Hailo也不希望他们的工程师为了基础设施和程序运行在哪个地方分神。<br><br><a href="http://www.slideshare.net/nathariel/microservices-and-elastic-resource-pools-with-amazon-ec2-container-service" class=" wrap external" target="_blank" rel="nofollow noreferrer">Hailo<i class="icon-external"></i></a>想要能够在弹性的资源池上根据服务的优先级和一些其他的度量来调度他们的容器。他们选用了Amazon ECS作为集群控制器，由于通过它提供的API接口用户可以简单的控制任务的状态也可以完整的暴露集群的状态。所有的一切就保证了Hailo可以构建自己自定义的调度器来实现符合自己程序业务逻辑的调度策略。<br><br><strong>Remind – PaaS</strong><br><br><a href="https://www.remind.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Remind<i class="icon-external"></i></a>是一个基于web和移动的应用可以让老师给学生发送短信，也可以和学生家长保持联系。Remind平台上拥有2400万的用户和150万的教师。每个月它会投递1.5亿条短信。Remind最初从全部的应用架构到消息投递引擎、前端API、web客户端、聊天后端都是是运行在Heroku平台上的。大多数的基础组件都是以大型的单点方式部署的。<br><br>随着用户数量的增加，Remind迫切的需求水平扩展的能力。所以在2014年底左右，工程师团队就开始探索切换到基于容器的微型服务架构上。他们的团队想要在AWS上构建一个和Heroku API兼容的PaaS平台。起初，他们的团队调研了很多开源的解决方案（例如：CoreOS、Kubernetes）去处理集群管理和容器的协调，但是由于工程师团队人力的短缺，他们没有时间去处理集群的基础设施的问题来保证集群的高可用。<br><br>在简要的评估Amazon ECS后，他们的团队就决定在ECS上构建他们的PaaS服务。Amazon ECS可以全方位的进行管控，提高了操作的效率可以让工程师的开发资源更多的去关注开发和发布自己的业务上；老板再也不用担心集群扩容和伸缩的问题了。6月份的时候，Remind将他们构建在ECS上的PaaS解决方案“Empire”开源了。Remind看到了显著的性能提升（无论是延迟减小、还是稳定性提升）当然，也有一些安全性的提升。他们接下来几个月的目标就是迁移90%的核心设施到Empire上。<br><br><strong>Amazon ECS – 一个全方位可管控的平台</strong><br><br>我们已经了解到很多我们用户的应用场景。Amazon ECS架构让我们可以给大家提供一个高伸缩性、高可用、低延迟的容器管理服务。用乐观并发控制API的方式全局共享集群的状态使得我们的用户可以构建出各种各样符合他们需求的容器服务。我们专注于帮我们的用户避免重复造轮子的“脏活累活”中。在Amazon ECS中，用户只需专注于开发伟大的应用，而无需分心在集群控制器的安装和部署上。<br><br>从我们去年11月发布预览版之后我们已经上线了很多新的特性。您可以在 <a href="https://aws.amazon.com/blogs/aws/ec2-container-service-latest-features-customer-successes-and-more/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Jeff Barr’s blog<i class="icon-external"></i></a> 上了解我们从去年到现在开发的新特性。欢迎阅读我们的<a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_GetStarted.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">文档<i class="icon-external"></i></a> 访问我们的<a href="https://console.aws.amazon.com/ecs/home?region=us-east-1#/firstRun" class=" wrap external" target="_blank" rel="nofollow noreferrer">控制台<i class="icon-external"></i></a>来试用我们的产品. 我们的RoadMap上已经规划了很多，我们十分重视大家的反馈：提问请到<a href="https://forums.aws.amazon.com/forum.jspa?forumID=187" class=" wrap external" target="_blank" rel="nofollow noreferrer">我们的论坛<i class="icon-external"></i></a> 或者reddit的 <a href="https://www.reddit.com/r/aws" class=" wrap external" target="_blank" rel="nofollow noreferrer">/r/aws<i class="icon-external"></i></a>.</p><br><p>禁止任何形式的转载，不惜诉诸法律</p><p>目前仅授权 <a href="http://51reboot.com" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">51reboot.com</span><span class="invisible"></span><i class="icon-external"></i></a> 在其公众号、网站、51cto博客转载</p></div><div class="entry-content"><h1 style="font-size:25px">Python编程（二）：Python进程、线程那点事儿</h1><hr>2015-08-17T10:01:15+08:00<h1>多进程，多线程编程</h1><p>系统程序员、运维开发程序员在面试的时候经常会被问及一个常见问题：</p><blockquote><p>进程是什么，线程是什么，进程和线程有什么区别？</p></blockquote><p>不得不承认，这么多年了。这个问题依旧是个很难以招架的问题，简单地说：</p><p>进程和线程有很多类似的性质，他们都可以被CPU作为一个单元进行调度，他们都拥有自己独立的栈（stack）等等。因此线程也被称作LWP（Lightweight Process，轻量级进程）；对应的进程也可以被称作为HWP（Heavyweight Process，重量级进程），从线程的角度看，进程就是只有一个线程的进程。如果一个进程有多个线程，那么它就能同时（只有在SMT系统中才有可能真正的“同时”）执行多个任务。他们的异同可以从以下几个角度来论述：</p><h4>调度</h4><p>在传统的计算机操作系统中，CPU调度的基本单位是进程。后来操作系统普遍引入了线程的概念，线程成为了CPU调度的基本单位，进程只能作为资源拥有的基本单位。</p><h4>并行</h4><p>由于线程的引入，原先一个进程只能有一个并发，现在一个进程可以有多个线程并行执行。早期的很多HTTP server都是通过线程来解决服务器的并发，比起之前用fork子进程来处理并发效率有了数倍的提升。这一切都得益于线程可以用进程更低的代价实现并发。</p><h4>共享</h4><p>一般来说Linux线程会继承或共享如下资源：</p><ul><li>进程代码段，如下图所示 <img src="https://pic2.zhimg.com/fd51b8365d1f03f70536a88e0a97aff9_b.jpg" data-rawwidth="1588" data-rawheight="896" class="origin_image zh-lightbox-thumb" width="1588" data-original="https://pic2.zhimg.com/fd51b8365d1f03f70536a88e0a97aff9_r.jpg"><br></li><li>进程的公有数据段内存（利用这些共享的数据，线程很容易的实现相互之间的通讯）</li><li>进程打开的FD（File Descriptor，文件描述符）</li><li>信号的处理器</li><li>进程用户ID（UID）与进程组ID（PGID）</li></ul><h4>隔离</h4><p>Linux的线程会独立拥有如下资源（非共享）：</p><ul><li>线程ID，在Linux中线程和进程共享ID空间，在UNIX系统中线程的ID是和进程ID不同层面的概念</li><li>寄存器的值，这其实就是线程能作为独立调度单元的最必要的保证</li><li>线程的栈，这是线程能并行运行的保证</li><li>优先级，Linux的系统设计使得线程和进程除了在某些资源的共享&amp;隔离有差异之外， 几乎是一视同仁的，所以他们可以有不同的priority。</li></ul><h2>多进程多线程的产生，在Linux系统中的地位</h2><p>Linux由于从一开始的定位就是一个多任务操作系统，从Linus Torvalds写出第一个版本的时候就有了进程的概念。比如我们耳熟能详的init进程的pid就是1。</p><p>线程的产生是为了解决并发问题，线程的定位也是轻量级的进程。</p><p>Linux内核在2.6版本之前都是没有线程的概念的，任务的最小调度单元都是进程。但Linux 在设计的时候就为线程的引入创造了良好的条件，Linux中著名的启动新进程系统调用fork就是通过内核调用clone实现的拷贝地址空间等资源。Linux通过改变内核调用clone的参数就很简单的创造出了线程。所以，从现代操作系统内核的调度的角度来说，进程和线程的差异微乎其微。</p><p>但不幸的是Linux早期的内核版本通过细微修改增加的线程机制和POSIX标准并不完全兼容，特别是信号处理、调度、跨进程同步的行为上。</p><p>为了推进Linux Threads和POSIX标准的统一，两拨人做了很多的努力：IBM牵头的NGPT (Next Generation POSIX Threads)和红帽（Red Hat）主推的NPTL（Native POSIX Thread Library）。这场竞争以NPTL的胜利告终，NPTL的用户态API就是我们现在常用的Pthread系列API。这场Red Hat战胜IBM的战争也基本确立了前者在Linux界扛把子的地位。</p><p>在NPTL成为Linux的POSIX事实标准之前，以FreeBSD为首的UNIX系统保持了对Linux的性能优势。这也就导致了很多历史比较老的公司当年系统都用的FreeBSD而不是Linux。</p><h3>为什么不能一味的开线程解决并发问题</h3><p>上面说到，线程的出现是为了解决Linux系统面临的日益增多的，并发编程的需求。</p><p>但就像我们这一小节的标题讲的一样：“不能一味的开线程解决并发问题”。</p><p>这是由于上下文切换（Context Switch）的代价：当计算机还处于单核时代的时候 ，就已经有了多任务操作系统。但单核的CPU在同一时刻只能运行一个进程的一个指令。 为了达到用户想要的“多任务”同时运行（比如，我在敲这段文字的时候，后台还在运行着 iTunes播放音乐，还有一个迅雷在我的虚拟机里运行）。Linux通过把CPU的时间切成 大小不等的时间片，通过内核的调度算法，让他们轮流来占用宝贵的CPU资源。由于切换的 时间片的大小一般都是微秒，所以在我们人类看来，计算机就在运行“多任务”。</p><h4>上下文切换（Context Switch）</h4><p>一个程序如果运行到了他的时间片结束还没有完成他的工作，那么，对不起，请把你需要 保存的数据（通常是一些CPU寄存器的数值）存储在内存中，然后排队去吧。</p><p>什么，稍等？NO，NO，NO 这不是一个用户态的进程能够和内核讨价还价的。</p><p>保存这个现场是需要一定的代价的，更严重的是，这将极大的影响CPU的分支预测， 影响系统性能。所以上下文切换（Context Switch）是我们要极力避免的。</p><p>进程或者线程开的多了，就会导致上下文切换（Context Switch）增多，严重影响 系统性能。</p><p>所以：“不能一味的开线程解决并发问题”。</p><h2>协程（coroutine）简介</h2><p>精辟的说，协程就是用户自己在进程中控制多任务的栈，尽可能的不让进程由于外部中断或者IO 的等待丧失CPU调度的时间片，从而在进程内部实现并发。</p><p>为了缓解，处理高并发的连接，Linux在很早的时候就引入了协程，来缓解上下文切换造成 的性能损失，在某种程度上实现异步编程。但由于协程的编程太过于晦涩难懂，所以即便是 协程在线程之前更早的被引入Linux内核，也始终没有流行起来。</p><p>下面是wikipedia对于协程的一段描述，大家可以参考一下：</p><blockquote><p>到2003年，很多最流行的编程语言，包括C和他的后继，都未在语言内或其标准库中直接支持协程。（这在很大程度上是受基于堆栈的子例程实现的限制）。</p><p>有些情况下，使用协程的实现策略显得很自然，但是此环境下却不能使用协程。典型的解决方法是创建一个子例程，它用布尔标志的集合以及其他状态变量在调用之间维护内部状态。代码中基于这些状态变量的值的条件语句产生出不同的执行路径及后继的函数调用。另一种典型的解决方案是用一个庞大而复杂的switch语句实现一个显式状态机。这种实现理解和维护起来都很困难。</p><p>在当今的主流编程环境里，线程是协程的合适的替代者，线程提供了用来管理“同时”执行的代码段实时交互的功能。因为要解决大量困难的问题，线程包括了许多强大和复杂的功能并导致了困难的学习曲线。当需要的只是一个协程时，使用线程就过于技巧了。然而——不像其他的替代者——在支持C的环境中，线程也是广泛有效的，对很多程序员也比较熟悉，并被很好地实现，文档化和支持。在POSIX里有一个标准的良定义的线程实现pthread.</p></blockquote><p>但近些年来，golang的努力，似乎又让这个古老的机制有了复苏的迹象。</p><h2>程序运行时的内存布局</h2><p>首先我们需要了解一个基础知识：程序运行时的内存，也就是我们在用户态能看到的内存地址，都不是物理内存中的地址。现代操作系统都会在物理内存上做一层内存映射（memory mapping）。所以如下图，每个进程的内存空间都是独立的，0x8000这种地址在物理地址中其实是不一样的地址。</p><img src="https://pic1.zhimg.com/4476ab6ffe6fcf0ce7391f5457aca09c_b.jpg" data-rawwidth="1346" data-rawheight="1044" class="origin_image zh-lightbox-thumb" width="1346" data-original="https://pic1.zhimg.com/4476ab6ffe6fcf0ce7391f5457aca09c_r.jpg"><p>如上图，每个线程，都有自己独立的“栈”、“寄存器”、“线程计数器”。每个进程可以有多个线程。 同一个进程里的线程都可以共享内存空间。</p><h2>多进程和多线程的选用场景</h2><p>在Linux系统编程中，多进程和多线程都有自己的用武之地。</p><p>多数情况他们的选用是按照他们的特性，其中最重要的特性就是上面提过的“共享”、“隔离”。</p><p>我们举个例子来说吧：</p><p>我们所熟知的memcached，是个典型多线程编程。之所以他是多线程，而不是多进程 主要的一个原因在于，memcached的多个线程需要共享内存中的Key-Value数据。所以多线程 是一个必然的选择。</p><p>然后就是大名鼎鼎的Nginx，是个典型的多进程编程。由于Nginx所要处理的HTTP请求都是 比较独立的，没有太多需要共享的数据。更重要的是Nginx需要支持“不停服务重启server”这一特性 这个功能也是这能在多进程框架下才能实现的。</p><p>所以，一个结论就是：到底是多进程好，还是多线程需要根据业务场景来分析选择。</p><h2>Python的GIL</h2><p>GIL是Global Interpreter Lock的缩写。顾名思义，就是Python解释器的一个全局锁。 它的产生是由于Python解释器在实现的时候作者为了“糙快猛”地实现出一个原型引入了很多 全局变量，由于全局变量的存在就要加锁，为了加锁那干脆一不做二不休，加个全局锁吧…… 嗯，当时情况应该就是这样的。</p><p>后来Python逐渐流行起来，很多模块的作者一方面也是为了简化问题，另一方面也是由于Python解释器 本身就有GIL，很多模块自己也肆无忌惮地引入了很多全局变量。</p><p>从此Python的GIL就走上了一条不归路，对Python程序员的影响就是，Python的多线程在同一时刻 只能有一个线程在运行。多线程情况下就是线程不停地在抢锁，抢得头破血流。</p><p>关于Python的GIL及其造成的性能影响，这篇David Beazley的这篇文章做了非常深刻的论述：</p><blockquote><p><a href="http://blog.51reboot.com/global-interpretor-lock/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Global Interpretor Lock<i class="icon-external"></i></a></p></blockquote><p>这部分的内容我们将在课上做更加深入的论述。</p><p>我们可以得到的结论：</p><ul><li>Python的多线程对CPU密集型是反作用，对IO密集型可以采用</li><li>Python多进程能充分利用多核CPU</li></ul></div><div class="entry-content"><h1 style="font-size:25px">Python编程（三）：Python之MVC</h1><hr>2015-08-19T12:18:43+08:00<p>很大程度上，web开发的模式演进路线和桌面UI的演进历史惊人的重合： 最开始，CGI拼字符串；对应桌面程序的console界面时代。 后来web开发开始MVC化，也基本上是借鉴桌面GUI开发时的数据库封装(Model)，布局文件(View)，业务逻辑(Control)。 后来web开发越来越注重用户的实时交互，从而变得富JavaScript化。个人感觉和桌面GUI库中的callback化很类似。</p><p>web开发以后的趋势应该是“控件化”，前后端的界限会变得模糊，可能会出现一套包含前后端的控件库。 比如一个登陆框，会抽象成一个类，里面包含了各种参数化的界面，动画，后端数据库映射，异常处理等等。 感觉RoR（Ruby on Rails）就有点这种发展趋势。<br><br></p><p>Python的web框架是非常非常之多的，这说明用Python开发web应用是非常流行的，但这也说明了一个 可悲的问题：Python不像Ruby那样有一个Rails似的一统天下的框架，我也经常被初学者问起Python web开发哪家强之类的问题。</p><p>Python Web框架一览：</p><blockquote><p><a href="https://wiki.python.org/moin/WebFrameworks/" class=" wrap external" target="_blank" rel="nofollow noreferrer">WebFrameworks<i class="icon-external"></i></a></p></blockquote><p>但平时工作和技术交流过程中我们发现，常用的Python web开发框架还是比较固定的</p><p>这里我分两大类讲</p><br><ul><li><p>大而全的框架</p><ul><li><p>Django，这个应该是现在Python界名气最大的开发框架了，真正的全功能。有个小tips，Django这个 单词，D是不发音的，所以这个单子发音大概是“坚狗”，不是“帝坚狗”。Django在实际的大型网站项目中 应用的也是比较少的，也是由于“样样行，样样都不精”。但值得一提的是Django里面有个django-admin 模块，可以用这个模块快速的开发出界面很炫酷的系统，一个朋友在这个模块上深度开发了一个项目，可以 供大家参考学习：<a href="https://github.com/sshwsfc/django-xadmin" class=" wrap external" target="_blank" rel="nofollow noreferrer">sshwsfc/django-xadmin · GitHub<i class="icon-external"></i></a></p><ul><li><p>官网</p><blockquote><p><a href="https://www.djangoproject.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">The Web framework for perfectionists with deadlines<i class="icon-external"></i></a></p></blockquote></li><li><p>Hello World</p><blockquote><p>稍微有点复杂，要配置route等。 详情请见：<a href="https://docs.djangoproject.com" class=" wrap external" target="_blank" rel="nofollow noreferrer">Django documentation<i class="icon-external"></i></a></p></blockquote></li></ul></li><li><p>web2py，这个框架由于Django的出现，现在逐渐式微了。</p></li></ul></li><li><p>轻量级框架</p><ul><li><p>web.py，这个框架是个有故事的框架。它的作者是天才Aaron Swartz，这个也是曾经最为流行的 Python轻量级web框架，但由于2013年作者自杀身亡后就基本停止更新了，现在用的人也逐渐变少了。</p><p>我认为还是有必要介绍一下它的作者，一个我很崇拜的人：</p><img src="https://pic1.zhimg.com/c2635f0a0a176efae2eb02ac4f9ce950_b.jpg" data-rawwidth="250" data-rawheight="347" class="content_image" width="250"><br><p>有一部关于他的纪录片，《互联网之子》 《The Internet's Own Boy: The Story of Aaron Swartz》 (2014)。 地址： <a href="http://movie.douban.com/subject/25785114/" class=" wrap external" target="_blank" rel="nofollow noreferrer">互联网之子 (豆瓣)<i class="icon-external"></i></a></p><blockquote><p>2013年1月11日，美国程序员、作家、政治活动组织者、互联网活动家Aaron H. Swartz在纽约自杀身亡，享年26岁。</p><p>Swartz出生于1986年，在14岁时，就已经加入W3C RDF核心工作组。在麻省理工学院，他与Web发明人Tim Berners-Lee一起工作，并协助开发并传播了Web上数据共享的标准，他与其他人联合写就了目前广泛使用的RSS 1.0规范。他是markdown的联合创始人，还是知名社会化新闻站点Reddit的三个拥有者之一，他还创造了python web应用框架web.py。</p><p>Swartz曾在Stanford读过一年，然后主动退学，创立公司Infogami，该公司受到Y Combinator首次Summer Founders Program资助。</p><p>2007年，他领导非盈利组织Open Library的创立，该组织意将世界上所有曾经出版过的书的信息都收集起来。</p><p>此后，Swartz在哈佛道德中心实验室（Harvard's Ethics Center Lab）完成了一个研究生奖学金，研究制度腐败（Instutional Corruption）。在2010年，他创建了<a href="http://DemandProgress.org" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">DemandProgress.org</span><span class="invisible"></span><i class="icon-external"></i></a>，发起运动“反抗互联网审查法案SOPA/PIPA”。</p><p>2011年7月，美国联邦大陪审团起诉Swartz，罪名是他从JSTOR在线杂志档案系统上下载了海量学术性文档，并大量散发。此后，他为Avaaz基金会工作，这是一家非盈利性组织，致力于“全球web运动，将人民群众的力量带入到政府决策过程中”。</p></blockquote></li><li><p>Flask，中文的意思是“烧瓶”。首先，我们需要明确一个概念，“轻量级”不代表功能简陋，而是设计思想。 一切MVC组件都是可替换的。其默认 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2。正因为良 好的扩展性，Flask也被称为 “microframework” ，因为它使用简单的核心，用 extension 增加其他功能。Flask没有默认使用的数据库、窗体验证工具。然而，Flask保留了扩增的弹性，可以用 Flask-extension加入这些功能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术。</p><ul><li><p>官网</p><blockquote><p><a href="http://flask.pocoo.org/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Welcome | Flask (A Python Microframework)<i class="icon-external"></i></a></p></blockquote></li><li><p>安装</p><blockquote><p>pip install Flask</p></blockquote></li><li><p>Hello World</p></li></ul><div class="highlight"><pre><code class="language-text">from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"

if __name__ == "__main__":
    app.run()
</code></pre></div></li><li><p>Bottle，中文的意思是“瓶子”。这个框架和Flask十分的的相似，相似到很多场景下把import Flask 直接改为 import bottle就能直接切换框架。但这连个框架的设计思想相差很多：</p><blockquote><p>Flask倾向于用已有的开源框架来“拼凑”出一个完整的框架，例如Werkzeug、Jinja2。避免 重复造轮子；而Bottle的作者似乎比较坚持，自己写的东西才有更好的可控性，作者也对“单文件” 的实现十分的坚持。</p></blockquote></li></ul><p>我个人比较喜欢Flask的方式，Flask也的确展示出了极强的可变行，如果你想将默认的模版引擎从Jinja2替换成Mako，你甚至都不用引入任何其它的扩展。</p></li></ul><br><p>更多精彩，请见 <a href="http://51reboot.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Reboot教育 - 高效你的学习<i class="icon-external"></i></a></p></div><div class="entry-content"><h1 style="font-size:25px">Python编程（四）：两个实用的Python的装饰器</h1><hr>2015-08-21T18:00:44+08:00<h2>超时函数<br></h2><p>这个函数的作用在于可以给任意可能会hang住的函数添加超时功能，这个功能在编写外部API调用 、网络爬虫、数据库查询的时候特别有用</p><p>timeout装饰器的代码如下：</p><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">signal</span><span class="o">,</span><span class="nn">functools</span> <span class="c">#下面会用到的两个库 </span>
<span class="k">class</span> <span class="nc">TimeoutError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span> <span class="k">pass</span> <span class="c">#定义一个Exception，后面超时抛出 </span>

<span class="k">def</span> <span class="nf">timeout</span><span class="p">(</span><span class="n">seconds</span><span class="p">,</span> <span class="n">error_message</span> <span class="o">=</span> <span class="s">'Function call timed out'</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">decorated</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_handle_timeout</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
      <span class="k">raise</span> <span class="n">TimeoutError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">_handle_timeout</span><span class="p">)</span>
      <span class="n">signal</span><span class="o">.</span><span class="n">alarm</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
      <span class="k">finally</span><span class="p">:</span>
        <span class="n">signal</span><span class="o">.</span><span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">wrapper</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">decorated</span>
</code></pre></div><p>使用：</p><div class="highlight"><pre><code class="language-python"><span class="nd">@timeout</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c">#限定下面的slowfunc函数如果在5s内不返回就强制抛TimeoutError Exception结束 </span>
<span class="k">def</span> <span class="nf">slowfunc</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">):</span>
  <span class="kn">import</span> <span class="nn">time</span>
  <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">)</span> <span class="c">#这个函数就是休眠sleep_time秒 </span>

<span class="n">slowfunc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c">#sleep 3秒，正常返回 没有异常 </span>


<span class="n">slowfunc</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c">#被终止 </span>

<span class="c">## 输出 </span>
<span class="o">---------------------------------------------------------------------------</span>
<span class="n">TimeoutError</span>                              <span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">)</span>
</code></pre></div><h3>Trace函数</h3><p>有时候出于演示目的或者调试目的，我们需要程序运行的时候打印出每一步的运行顺序 和调用逻辑。类似写bash的时候的bash -x调试功能，然后Python解释器并没有 内置这个时分有用的功能，那么我们就“自己动手，丰衣足食”。</p><p>Trace装饰器的代码如下：</p><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span><span class="nn">os</span><span class="o">,</span><span class="nn">linecache</span>
<span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">globaltrace</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">why</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">why</span> <span class="o">==</span> <span class="s">"call"</span><span class="p">:</span> <span class="k">return</span> <span class="n">localtrace</span>
    <span class="k">return</span> <span class="bp">None</span>
  <span class="k">def</span> <span class="nf">localtrace</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">why</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">why</span> <span class="o">==</span> <span class="s">"line"</span><span class="p">:</span>
      <span class="c"># record the file name and line number of every trace </span>
      <span class="n">filename</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span>
      <span class="n">lineno</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_lineno</span>
      <span class="n">bname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="k">print</span> <span class="s">"{}({}): {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>  <span class="n">bname</span><span class="p">,</span>
        <span class="n">lineno</span><span class="p">,</span>
        <span class="n">linecache</span><span class="o">.</span><span class="n">getline</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">lineno</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)),</span>
    <span class="k">return</span> <span class="n">localtrace</span>
  <span class="k">def</span> <span class="nf">_f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">settrace</span><span class="p">(</span><span class="n">globaltrace</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">settrace</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
  <span class="k">return</span> <span class="n">_f</span>
</code></pre></div><p>使用：</p><div class="highlight"><pre><code class="language-python"><span class="nd">@trace</span>
<span class="k">def</span> <span class="nf">xxx</span><span class="p">():</span>
  <span class="k">print</span> <span class="mi">1</span>
  <span class="k">print</span> <span class="mi">22</span>
  <span class="k">print</span> <span class="mi">333</span>

<span class="n">xxx</span><span class="p">()</span> <span class="c">#调用 </span>

<span class="c">## 输出 </span>
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">da50741ac84e</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>     <span class="k">print</span> <span class="mi">1</span> <span class="c"># @trace 的输出 </span>
<span class="mi">1</span>
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">da50741ac84e</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>     <span class="k">print</span> <span class="mi">22</span> <span class="c"># @trace 的输出 </span>
<span class="mi">22</span>
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">da50741ac84e</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>     <span class="k">print</span> <span class="mi">333</span> <span class="c"># @trace 的输出 </span>
<span class="mi">333</span>
</code></pre></div></div><div class="entry-content"><h1 style="font-size:25px">网络编程（一）：演进——从Apache到Nginx</h1><hr>2015-09-07T18:07:05+08:00<h4>Apache</h4><p>Apache HTTP服务器是 Robert McCool 在1995年写成，并在1999年开始在Apache软件基金会的 框架下进行开发。由于Apache HTTP服务器是基金会最开始的一个项目也是最为有名的一个项目， 所以通常大家提到Apache这个词都是说的Apache HTTP Server。</p><p>Apache web服务器从1996年开始就是互联网上最为流行的HTTP服务器。Apache之所以这么流行 很大程度上是由于相比其他的软件项目，在Apache基金会的精心维护下他的文档十分的详尽还有 集成的支持服务。</p><p>Apache由于其可变性、高性能和广泛的支持，经常是系统管理员的首选。他可以通过一系列 的语言相关的扩展模块支持很多解释型语言的后端，而不需要连接一个独立的后端程序。</p><p>Apache软件基金会也是利用开源软件盈利的一个范本。时至今日，Apache软件基金会 已经枝繁叶茂，在基金会名下的开源项目我们耳熟能详的有：</p><ul><li>Apache HTTP Server</li><li>Ant（Java的编译工具）</li><li>ActiveMQ（MQ集群）</li><li>Cassandra（强一致的分布式KV数据库）</li><li>CloudStack（OpenStack的劲敌）</li><li>CouchDB（KV数据库）</li><li>Flume（日志收集工具）</li><li>Hadoop、Hbase、Hive</li><li>Kafka（流式计算）</li><li>Lucene（开源搜索引擎）</li><li>Maven（Java编译&amp;依赖管理工具）</li><li>Mesos（分布式协调）</li><li>OpenNLP（开源自然语言处理库）</li><li>OpenOffice（开源的类Office工具）</li><li>Perl（Perl语言）</li><li>Spark（分布式计算集群）</li><li>Storm（流式计算）</li><li>Struts（Java SSH框架的第二个S）</li><li>Subversion（SVN，你懂的）</li><li>Tcl（Tcl语言）</li><li>Thrift（Java网络框架）</li><li>Tomcat（大名鼎鼎的Java容器）</li><li>ZooKeeper（分布式协调集群）</li></ul><p>完整的Apache基金会的项目列表参见：<a href="http://apache.org/index.html#projects-list" class=" wrap external" target="_blank" rel="nofollow noreferrer">Welcome to The Apache Software Foundation!<i class="icon-external"></i></a></p><h4>Nginx</h4><p>2002年，一个叫Igor Sysoev的俄罗斯哥们儿（貌似俄罗斯叫Igor的人挺多的） 写出了一个叫Nginx（和Engine X谐音，取引擎之义）。 那时候有一个时代背景，当时C10K（Concurrency 10K，1万并发）问题还是困扰绝大多数 web服务器的一个难题。Nginx利用异步事件驱动的架构写成，是C10K问题的一个很好的答卷。 Nginx的第一个公开发行版是在2004年发布的，之前都是作为俄罗斯访问量第二的网站Rambler 的内部使用。</p><p>Nginx的主要优势在于“轻、快、活”：</p><h4>轻</h4><blockquote><p>很低的资源占用，甚至能在很多嵌入式设备上运行。</p></blockquote><h4>快</h4><blockquote><p>响应速度超快，几乎不会由于高并发影响响应速度。</p></blockquote><h4>活</h4><blockquote><p>配置灵活，广泛的模块支持。</p></blockquote><p>网上关于Apache和Nginx性能比较的文章非常多，基本上有如下的定论：</p><ol><li>Nginx在并发性能上比Apache强很多，如果是纯静态资源（图片、JS、CSS）那么Nginx是不二之选。</li><li>Apache有mod_php、在PHP类的应用场景下比Nginx部署起来简单很多。一些老的PHP项目用Apache 来配置运行非常的简单，例如Wordpress。</li><li>对于初学者来说Apache配置起来非常复杂冗长的类XML语法，甚至支持在子目录放置.htaccess 文件来配置子目录的属性。Nginx的配置文件相对简单一点。</li><li>Nginx的模块比较容易写，可以通过写C的mod实现接口性质的服务，并且拥有惊人的性能。 分支OpenResty，可以配合lua来实现很多自定义功能，兼顾扩展性和性能。</li></ol><p>这里我们要着重讨论的是为什么Nginx在并发性能上比Apache要好很多。</p><p>想要了解这个问题，不得不先做一些铺垫，讲讲并发网络编程的一些历史：</p><h4>壹 最原始</h4><p>最原始的网络编程的伪代码大致是这样：</p><div class="highlight"><pre><code class="language-python"><span class="mo">00</span> <span class="n">listen</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>  <span class="c"># 监听在接收服务的端口上 </span>
<span class="mo">01</span> <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>   <span class="c"># 一直循环 </span>
<span class="mo">02</span>  <span class="n">conn</span> <span class="o">=</span> <span class="n">accept</span><span class="p">()</span>    <span class="c"># 接收连接 </span>
<span class="mo">03</span>  <span class="n">read_content</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="c"># 读取连接发送过来的请求 </span>
<span class="mo">04</span>  <span class="n">response</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="c"># 执行业务逻辑，并得到给客户端回应的内容 </span>
<span class="mo">05</span>  <span class="n">conn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="c"># 将回应写回给连接 </span>
</code></pre></div><p>我们需要了解，最原始的Linux中accept、read、write调用都是 阻塞的（现在，阻塞也是这些调用的默认行为）。这就导致了以上代码只能同时 处理一个连接，所以就有了下面的方法：</p><h4>贰 每个连接开一个进程</h4><p>后来，大家想到了办法：</p><div class="highlight"><pre><code class="language-python"><span class="mo">00</span> <span class="n">listen</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>  <span class="c"># 监听在接收服务的端口上 </span>
<span class="mo">01</span> <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>   <span class="c"># 一直循环 </span>
<span class="mo">02</span>  <span class="n">conn</span> <span class="o">=</span> <span class="n">accept</span><span class="p">()</span>    <span class="c"># 接收连接 </span>
<span class="mo">03</span>  <span class="k">if</span> <span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="mo">04</span>    <span class="c"># 子进程 </span>
<span class="mo">05</span>    <span class="n">read_content</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="c"># 读取连接发送过来的请求 </span>
<span class="mo">06</span>    <span class="n">response</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="c"># 执行业务逻辑，并得到给客户端回应的内容 </span>
<span class="mo">07</span>    <span class="n">conn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="c"># 将回应写回给连接 </span>
</code></pre></div><p>用子进程来处理连接，父进程继续等待连接进来。但这种方式有如下两个明显的缺陷：</p><ol><li>fork()调用比较费时，需要对进程进行内存拷贝。即使现在的Linux普遍 引入了COW（Copy On Write）技术（fork的时候不做内存拷贝，只有其中一个 副本发生了write的时候才进行copy）加速了fork的效率，但fork依旧是个 比较“重”的系统调用。</li><li>较多的内存占用，也是由于上述的内存复制造成的。</li></ol><h4>叁 引入线程</h4><p>得益于之前提过的Linux对于线程的引入，上面例子的开进程，被换成了开线程， 这样，上一小节说的两个缺陷都大大的被缓解了。</p><h4>肆 进程/线程池</h4><p>计算机领域有很多算法或者是方法都会用到一种智慧：“空间换时间”。 即用使用更多内存的方式换取更快的运行速度：事先创建出很多进程/线程 ，就像一个池子，这样虽然会浪费一部分的内存，但连接过来的时候就省去了 开启进程/线程的时间。</p><p>但这种方式会有一个比较显著的缺陷：当并发数大于进程/线程池的大小的时候 性能就会发生很大的下滑，退化成“贰”的情况。</p><h4>伍 非阻塞&amp;事件驱动</h4><p>那么，是不是想要达到高性能就一定要付出高系统资源占用呢？ 答案是否定的，如果我们注意观察生活中的一个细节，肯德基和麦当劳的不同 服务方式：</p><ul><li>肯德基<ol><li>服务员在前台问：“先生/小姐，有什么可以帮你？”</li><li>顾客，思考一下点什么比较好：“我要，xxxxx”</li><li>服务员去后台配餐、取餐，3分钟过去了：“您的餐齐了，下一位”</li></ol></li><li>麦当劳<ol><li>服务员在前台问：“先生/小姐，有什么可以帮你？”</li><li>顾客：“我要，xxxxx”。如果顾客思考超过5秒：“后面的顾客请先点”； 点完餐，前台服务员继续为下一位顾客点餐。后台有别的服务员完成配餐。</li></ol></li></ul><p>可以思考一下，这两种运作方式那种比较好：</p><ol><li>在肯德基，如果遇到需要纠结半天吃什么的客户。服务员和后面的顾客 都会陷入较长时间的等候。原因就是如果最前面的客户先让后面的顾客点餐 ，他想好了还需要较长时间的等候。相比之下，麦当劳就更胜一筹。</li><li>在麦当劳，后面配餐的服务员如果发现有两个订单都要了可乐。他可以 智能地把两个订单的可乐一次性灌好，这样会大大的提高效率。各个岗位上 的服务员可以灵活的采用各种方式优化自己的工作效率。</li></ol><p>这里，肯德基的服务方式就是古老的进程/线程池；麦当劳的服务方式 就是一个简单的非阻塞&amp;事件驱动。</p><p>那么，非阻塞&amp;事件驱动这么好，为什么大家没有一开始就采用这种方式呢？ 原因有二：</p><ol><li>非阻塞&amp;事件驱动需要系统的支持，提供non-blocking版的整套 系统调用。</li><li>非阻塞&amp;事件驱动编程难度较大，需要很高的抽象思维能力， 把整个任务拆解；采用有限状态机编程才能实现。</li></ol><br><p>更多精彩，请见 <a href="http://51reboot.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Reboot教育 - 高效你的学习<i class="icon-external"></i></a></p></div><div class="entry-content"><h1 style="font-size:25px">网络编程（二）：戏说非阻塞网络编程</h1><hr>2015-11-01T22:15:08+08:00<p>在数据加密领域举例子，我们经常会提到Alice和Bob，我们也继续延续这种传统。</p><p>在遥远的1752年的英国，电报这种可以穿越千山万水发送消息的东西还没被发明。 Alice和Bob是大学认识的一对情侣。由于毕业找工作的原因，Alice在利物浦工作 ，Bob在曼彻斯特工作（笔者掰着指头就能编出这两个了o_o|| ）。</p><img src="https://pic3.zhimg.com/22dc42d229e6b2b25f3c9c152f76b3f6_b.png" data-rawwidth="1098" data-rawheight="581" class="origin_image zh-lightbox-thumb" width="1098" data-original="https://pic3.zhimg.com/22dc42d229e6b2b25f3c9c152f76b3f6_r.png"><p>虽然在不同的城市工作，但这毫不影响两个人的感情，他们经常写信来互诉衷肠。 那么问题就来了，这两个城市路程大约60km，邮差每天送信一次。 天气好的时候，Alice当天写的信Bob晚上就能收到，但如果遇上坏天气或者邮差睡过头了， 几天之后Bob才能看到心爱的Alice的亲笔信。</p><p>Bob非常思念Alice，魂不守舍的时候就去邮箱里看看有没有Alice的消息， 没有Alice的信就一直守候在信箱旁，等待邮差送信过来。</p><p>如果把Alice和Bob看作是互联网上的两台主机，Bob这种行为在计算机网络通信领域被叫做 阻塞式通信。我们可以看到，Bob这种行为无疑是十分愚蠢而幼稚的， 为了等信导致不能进行其它日常的事务处理。如果设置超时时间，极端点儿是有可能饿死在信箱旁的。</p><img src="https://pic4.zhimg.com/6074bb6fae5cb42d2721d7a12058a2cf_b.png" data-rawwidth="403" data-rawheight="375" class="content_image" width="403"><p>当然，我们的Bob同学没有那么极端，每次在信箱前等待5分钟后就去做别的事情。</p><p>然而，Bob同学依然面临一个矛盾。虽然不会永远的傻傻等待Alice的信件，但：</p><ul><li>如果太频繁地检查邮箱，手头的事情会被经常打断，太耗费精力。</li><li>如果检查的间隔时间太长，就不可能每次都及时收到Alice的信件。</li></ul><p>如果用网络服务器来类比Bob同学，伪代码是这样的：</p><div class="highlight"><pre><code class="language-python"><span class="n">CHECK_INTERVAL</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">60</span> <span class="c"># 检测间隔</span>
<span class="n">mailbox_fd</span> <span class="o">=</span> <span class="n">listen</span><span class="p">(</span><span class="n">MAILBOX</span><span class="p">)</span> <span class="c"># 假设邮箱对应着一个端口</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="n">mails</span> <span class="o">=</span> <span class="n">CheckMailBox</span><span class="p">(</span><span class="n">mailbox_fd</span><span class="p">)</span> <span class="c"># 看一眼mail</span>
  <span class="k">if</span> <span class="n">mails</span><span class="p">:</span> <span class="c"># 说明有信来了！！</span>
    <span class="c"># 处理邮件</span>
    <span class="n">processMail</span><span class="p">()</span>
  <span class="n">sleep</span><span class="p">(</span><span class="n">CHECK_INTERVAL</span><span class="p">)</span>
</code></pre></div><p>Bob同学面临的矛盾，之于网络服务器就是CHECK_INTERVAL：</p><ul><li>设置太小，就会频繁地进行CheckMailBox()，CPU占用率就会非常高。</li><li>设置太大，可能会导致邮件在sleep(CHECK_INTERVAL)的时候到了，不能被及时处理。</li></ul><p>难道说这就没有两全其美的办法了么？</p><p>我们的工程师Bob在经历了一番思索后想到了一个绝妙的办法：</p><blockquote><p>在信箱的口上加一个铃铛，让邮差放信的时候帮忙摇一下铃铛，Bob听到铃响再来取信。</p></blockquote><img src="https://pic3.zhimg.com/0002a56d2a62b1bc77c7ebae29bdcd7e_b.png" data-rawwidth="596" data-rawheight="552" class="origin_image zh-lightbox-thumb" width="596" data-original="https://pic3.zhimg.com/0002a56d2a62b1bc77c7ebae29bdcd7e_r.png"><br><p>这样，Bob就可以专心工作，既不用分心来查看邮箱，也能及时的查阅新邮件。</p><p>但细心的同学发现，我们这里略过了一个重要的细节。要想专心工作需要一个外部前提：</p><blockquote><p>需要邮差大哥配合，每次来信箱放完信，摇一下铃铛。</p></blockquote><p>每次来送信的邮差又不总是同一个人，和每个邮差交代一下也不现实。</p><p>这当然还是难不倒我们的工程师Bob同学。Bob把邮箱改造了一下：</p><blockquote><p>每次邮差把信放进邮箱，邮箱上就会竖起一个小旗子，表示有信在里面。</p></blockquote><img src="https://pic2.zhimg.com/2161889380f7850f7aac1357fcbca7ad_b.jpg" data-rawwidth="660" data-rawheight="438" class="origin_image zh-lightbox-thumb" width="660" data-original="https://pic2.zhimg.com/2161889380f7850f7aac1357fcbca7ad_r.jpg"><p>这就像服务端编程中，我们不能要求每一个TCP连接提供“通知”的机制， 只能从服务器自身的机制上想办法。我们在Linux、UNIX网络编程上经常用到的： select()、poll()、epoll()都是我们上面说的Bob改造过的邮箱类似的系统调用机制。</p><p>只是他们之间有一些细节的差异而已：</p><h3>select()和poll()</h3><p>select()是在1983年首次出现在4.2版的BSD UNIX中。 poll()出现得稍晚一些，首次出现同样是在UNIX平台， 晚到了1997年才在2.1.23版本的Linux内核中首次被加入。</p><p>select()有一个众所周知的问题，只能处理小于等于1024的文件描述符； poll()虽然没有这个问题，但在很多平台的实现里，poll()和select()的实现基本是同一套代码。 只是提供了两套不同的接口罢了:</p><ul><li><p>select:</p><div class="highlight"><pre><code class="language-c"><span class="cp">#include &lt;sys/select.h&gt;</span>

<span class="kt">int</span>
<span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">errorfds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span> <span class="kr">restrict</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre></div></li><li><p>poll:</p><div class="highlight"><pre><code class="language-c"><span class="cp">#include &lt;poll.h&gt;</span>

<span class="kt">int</span>
<span class="nf">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[],</span> <span class="kt">nfds_t</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre></div></li></ul><p>select()在处理大量的网络连接带来的socket描述符低效的问题仍旧存在于poll()中。</p><p>当年，select()被设计出来的时候， UNIX和Linux内核的设计者怎么也没意料到日后会在服务端处理那么多的socket连接。</p><div class="highlight"><pre><code class="language-text">如果UNIX和Linux是中国人发明的估计就没有这个问题了，毕竟欧美人少，
很少有机会见识成百万，上千万乃至上亿的并发。

哈哈，说笑了，其实是这样，早些年UNIX开发者都是些大学的教授和学生，
实在没想到UNIX和TCP/IP在日后能有这么大的影响力。
所以就有了IPv4、select()等等这些对用户量预估不够给后世的困扰了。
</code></pre></div><h4>select()和poll()的效率问题</h4><p>我们现在回到正题，简单聊一下select()和poll()为什么效率低的问题：</p><blockquote><p>假设我们的Bob同学由于工作十分出色，升职加薪，工作上的事情也比当 初多了很多。</p><br><p>Bob的信箱就是一个socket，Alice和Bob通过这条虚拟的socket进行 沟通。我们Bob还有很多朋友和工作上的伙伴，Bob为每个联系人都设立了 单独的邮箱，所以也请了一个秘书专门帮着收信。</p><br><p>这时Bob相当于就是一个高并发的服务器。我们的select()就相当于是 Bob的秘书。秘书在处理邮箱的时候的方法也十分的原始，就是Bob在调用 select()的时候（大家应该能明白我的意思），秘书去挨个查看邮箱上的 小旗子。这样做的时间复杂度是O(n)的。</p><br><p>邮箱数量少一些还好，秘书虽然累但也能处理得过来。但太多了秘书实在 处理起来费劲，我们的秘书比较有个性，跟Bob同学讲明了，如果邮箱数量 到了1024以上她就罢工。Bob虽然心有怨言，但明白秘书的苦衷也是在没 有好办法。</p><br><p>后来，Bob这里又找了一个名叫poll()的秘书，poll()倒是比select() 更加任劳任怨，并没有给Bob提出1024这个上限。但无奈还是用的select() 的老办法：Bob调用的时候还是挨个看邮箱。数量多了不免要查上个半天。</p></blockquote><h4>如何解决高并发的问题</h4><p>这个问题是个很大的问题，我们这里就不展开说，后面还会提。 但有一点我们都很清楚，首先要解决的是select()和poll()的效率问题。</p><p>然后，epoll嘭地一声横空出世，全剧终。</p><p>等等，太坑爹了，板凳都搬来了，你就让我听这个？</p><p>那我还是正经的说说吧：</p><p>下面这段摘自wikipedia：<a href="https://zh.wikipedia.org/wiki/Epoll" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">zh.wikipedia.org/wiki/E</span><span class="invisible">poll</span><span class="ellipsis"></span><i class="icon-external"></i></a></p><blockquote><p>epoll是Linux内核的可扩展I/O事件通知机制。它设计目的只在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能 (举例来说：旧有的系统函数所花费的时间复杂度为O(n)，epoll则耗时O(1))。 epoll与FreeBSD的kqueue类似，底层都是由可配置的操作系统内核对象建构而成， 并以文件描述符(file descriptor)的形式呈现于用户空间。</p></blockquote><p>epoll由下面几个系统调用组成：</p><div class="highlight"><pre><code class="language-c"><span class="kt">int</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span> <span class="n">event</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span> <span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre></div><p>为了解决高并发问题，大约在2000年，Jonathan Lemon在FreeBSD内核中实现了第一个版本 的kqueue，并在FreeBSD 4.1版本发布。之后FreeBSD在处理高并发的问题上一直领先于Linux。</p><p>在2002年，Linux的2.5.44版本（测试版本）首次加入了epoll机制。 直到2004年，在Linux的2.6.9版本epoll相关的API才稳定下来， Linux的高并发机制这才跟赶上FreeBSD。</p><p>所以，在2004年之前很多公司在服务器操作系统选型的时候选择的是FreeBSD，而不是Linux。</p><p>各种操作系统在解决这个问题的办法上也是百花齐放：</p>技术操作系统kqueueUNIX (FreeBSD、MacOS)epollLinux 2.5.44/2.6.9IOCP (IO Completion Port)Windows NT 3.5, AIX, Solaris 10<p>如果继续用Alice和Bob的例子来说的话事情就是这样的：</p><p>看着这两个秘书这么辛苦，Bob终于坐不住了，想出来一个绝妙的主意：</p><div class="highlight"><pre><code class="language-text">给秘书们设计了一个指示板和邮箱联动，邮箱里有信的时候，指示板上灯就会亮起来。
这样，哪个邮箱里有信秘书就一目了然了。这样检查邮箱这件事情的时间复杂度就是
O(1)了。
</code></pre></div><p>指示板如下图所示：</p><img src="https://pic2.zhimg.com/7eccad5725b430ab2713bdbb5c8dd509_b.png" data-rawwidth="459" data-rawheight="245" class="origin_image zh-lightbox-thumb" width="459" data-original="https://pic2.zhimg.com/7eccad5725b430ab2713bdbb5c8dd509_r.png"><h4>epoll的ET和LT</h4><p>关于epoll的ET和LT之前已经说过，这里借用Alice和Bob的例子。</p><ul><li><p>ET (Edge Triggered) 边沿触发</p><p>来了信件，指示板上的灯只闪一下。</p></li><li><p>LT (Level Triggered) 水平触发</p><p>来了信件，指示板上的灯一直亮着，直到信箱中的信全部被取走。</p></li></ul><p>=================</p><p>#未完待续#</p><br><p># 得到授权之前，拒绝任何形式的转载<br></p><p>服务端网络编程交流群：348904670 </p></div><div class="entry-content"><h1 style="font-size:25px">网络编程（三）：从libevent到事件通知机制</h1><hr>2015-11-03T14:20:39+08:00<p>由于POSIX标准的滞后性，事件通知API的混乱一直保持到现在， 所有就有libevent、libev甚至后面的libuv的出现为跨平台编程扫清障碍。</p><p>下面是WikiPedia对于libevent的介绍：</p><blockquote><p>libevent是一个异步事件处理软件函式库，以BSD许可证发布。 libevent提供了一组应用程序编程接口（API），让程序员可以设定某些事件发生时所执行的函式，也就是说，libevent可以用来取代网络服务器所使用的事件循环检查框架。</p><p>由于可以省去对网络的处理，且拥有不错的效能， 有些软件使用libevent作为网络底层的函式库，如：Chromium（Chrome的开源版）、 memcached、Tor。</p></blockquote><p>按照libevent的官方网站，libevent库提供了以下功能：当一个文件描述符的特定事件 （如可读，可写或出错）发生了，或一个定时事件发生了， libevent就会自动执行用户指定的回调函数，来处理事件。</p><p>目前，libevent已支持以下接口/dev/poll, kqueue(2), event ports, select(2), poll(2) 和epoll(4)。</p><p>libevent的内部事件机制完全是基于所使用的接口的。因此libevent非常容易移植， 也使它的扩展性非常容易。目前，libevent已在以下操作系统中编译通过： Linux，BSD，Mac OS X，Solaris和Windows。</p><p>libevent的高明之处还在于，它把fd读写、信号、DNS、定时器甚至idle（空闲） 都抽象化成了event（事件）。</p><p>我们可以简单看一下一个简单的基于libevent的网络server， 这有助于我们理解event-driven programming（事件驱动编程）， 也为我们后续的实操做准备。</p><p>我在代码中增加了详细的注释，希望大家能大致明白event-driven programming 的一半方法：</p><div class="highlight"><pre><code class="language-c"><span class="cm">/*</span>
<span class="cm">    这是一个示例性质的libevent的程序，监听在TCP的9995端口。</span>
<span class="cm">    当连接建立成功后，它将会给Client回应一个消息"Hello, World!\n"</span>
<span class="cm">    发送完毕后就将连接关闭。</span>

<span class="cm">    程序也处理了SIGINT (ctrl-c)信号，收到这个信号后优雅退出程序。</span>

<span class="cm">    这个程序也用到了一些libevent比较高级的API：“bufferevent”</span>
<span class="cm">    这套API将buffer的“水位线”也抽象成了event来处理，灵感应该是来自</span>
<span class="cm">    Windows平台的IOCP。</span>
<span class="cm">*/</span>

<span class="c1">// 引入常用Linux系统头文件 </span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;errno.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;signal.h&gt;</span>
<span class="cp">#include &lt;netinet/in.h&gt;</span>
<span class="cp">#include &lt;arpa/inet.h&gt;</span>
<span class="cp">#include &lt;sys/socket.h&gt;</span>

<span class="c1">// 引入libevent 2.x相关的头文件 </span>
<span class="cp">#include &lt;event2/bufferevent.h&gt;</span>
<span class="cp">#include &lt;event2/buffer.h&gt;</span>
<span class="cp">#include &lt;event2/listener.h&gt;</span>
<span class="cp">#include &lt;event2/util.h&gt;</span>
<span class="cp">#include &lt;event2/event.h&gt;</span>

<span class="c1">// 定义字符串常量，将会回应给Client用 </span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">MESSAGE</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hello, World!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="c1">// server监听的端口 </span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">PORT</span> <span class="o">=</span> <span class="mi">9995</span><span class="p">;</span>

<span class="c1">// 定义几个event callback的prototype（原型） </span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">listener_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">evconnlistener</span> <span class="o">*</span> <span class="p">,</span> <span class="kt">evutil_socket_t</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">socklen</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">conn_writecb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span> <span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">conn_eventcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span> <span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">signal_cb</span><span class="p">(</span><span class="kt">evutil_socket_t</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="p">);</span>

<span class="c1">// 定义标准的main函数 </span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// event_base是整个event循环必要的结构体 </span>
    <span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span> <span class="n">base</span><span class="p">;</span>
    <span class="c1">// libevent的高级API专为监听的FD使用 </span>
    <span class="k">struct</span> <span class="n">evconnlistener</span> <span class="o">*</span> <span class="n">listener</span><span class="p">;</span>
    <span class="c1">// 信号处理event指针 </span>
    <span class="k">struct</span> <span class="n">event</span> <span class="o">*</span> <span class="n">signal_event</span><span class="p">;</span>
    <span class="c1">// 保存监听地址和端口的结构体 </span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sin</span><span class="p">;</span>

    <span class="c1">// 分配并初始化event_base </span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">event_base_new</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果发生任何错误，向stderr（标准错误输出）打一条日志，退出 </span>
        <span class="c1">// 在C语言里，很多返回指针的API都以返回null为出错的返回值 </span>
        <span class="c1">// if (!base) 等价于 if (base == null) </span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not initialize libevent!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 初始化sockaddr_in结构体，监听在0.0.0.0:9995 </span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sin</span><span class="p">));</span>
    <span class="n">sin</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">sin</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

    <span class="c1">// bind在上面制定的IP和端口，同时初始化listen的事件循环和callback：listener_cb </span>
    <span class="c1">// 并把listener的事件循环注册在event_base：base上 </span>
    <span class="n">listener</span> <span class="o">=</span> <span class="n">evconnlistener_new_bind</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">listener_cb</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="p">)</span><span class="n">base</span><span class="p">,</span>
        <span class="n">LEV_OPT_REUSEABLE</span><span class="o">|</span><span class="n">LEV_OPT_CLOSE_ON_FREE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">sin</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">listener</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果发生任何错误，向stderr（标准错误输出）打一条日志，退出 </span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not create a listener!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 初始化信号处理event </span>
    <span class="n">signal_event</span> <span class="o">=</span> <span class="n">evsignal_new</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">,</span> <span class="n">signal_cb</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="p">)</span><span class="n">base</span><span class="p">);</span>

    <span class="c1">// 把这个callback放入base中 </span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_event</span> <span class="o">||</span> <span class="n">event_add</span><span class="p">(</span><span class="n">signal_event</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not create/add a signal event!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 程序将在下面这一行内启动event循环，只有在调用event_base_loopexit后 </span>
    <span class="c1">// 才会从下面这个函数返回，并向下执行各种清理函数，导致整个程序退出 </span>
    <span class="n">event_base_dispatch</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>

    <span class="c1">// 各种清理free </span>
    <span class="n">evconnlistener_free</span><span class="p">(</span><span class="n">listener</span><span class="p">);</span>
    <span class="n">event_free</span><span class="p">(</span><span class="n">signal_event</span><span class="p">);</span>
    <span class="n">event_base_free</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"done</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 监听端口的event callback </span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">listener_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">evconnlistener</span> <span class="o">*</span> <span class="n">listener</span><span class="p">,</span> <span class="kt">evutil_socket_t</span> <span class="n">fd</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span> <span class="n">sa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">socklen</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">user_data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="n">user_data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span> <span class="n">bev</span><span class="p">;</span>

    <span class="c1">// 新建一个bufferevent，设定BEV_OPT_CLOSE_ON_FREE， </span>
    <span class="c1">// 保证bufferevent被free的时候fd也会被关闭 </span>
    <span class="n">bev</span> <span class="o">=</span> <span class="n">bufferevent_socket_new</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">BEV_OPT_CLOSE_ON_FREE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bev</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error constructing bufferevent!"</span><span class="p">);</span>
        <span class="n">event_base_loopbreak</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 设定写buffer的event和其它event </span>
    <span class="n">bufferevent_setcb</span><span class="p">(</span><span class="n">bev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">conn_writecb</span><span class="p">,</span> <span class="n">conn_eventcb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">// 开启向fd中写的event </span>
    <span class="n">bufferevent_enable</span><span class="p">(</span><span class="n">bev</span><span class="p">,</span> <span class="n">EV_WRITE</span><span class="p">);</span>
    <span class="c1">// 关闭从fd中读写入buffer的event </span>
    <span class="n">bufferevent_disable</span><span class="p">(</span><span class="n">bev</span><span class="p">,</span> <span class="n">EV_READ</span><span class="p">);</span>
    <span class="c1">// 向buffer中写入"Hello, World!\n" </span>
    <span class="c1">// 上面的操作保证在fd可写时，将buffer中的内容写出去 </span>
    <span class="n">bufferevent_write</span><span class="p">(</span><span class="n">bev</span><span class="p">,</span> <span class="n">MESSAGE</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">MESSAGE</span><span class="p">));</span>
<span class="p">}</span>


<span class="c1">// 每次fd可写，数据非阻塞写入后，会雕也难怪conn_writecb </span>
<span class="c1">// 这个函数每次检查eventbuffer的剩余大小，如果为0 </span>
<span class="c1">// 表示数据已经全部写完，将eventbuffer free掉 </span>
<span class="c1">// 由于在上面设定了BEV_OPT_CLOSE_ON_FREE，所以fd也会被关闭 </span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">conn_writecb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span> <span class="n">bev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">user_data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">evbuffer</span> <span class="o">*</span> <span class="n">output</span> <span class="o">=</span> <span class="n">bufferevent_get_output</span><span class="p">(</span><span class="n">bev</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">evbuffer_get_length</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"flushed answer</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">bufferevent_free</span><span class="p">(</span><span class="n">bev</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 处理读、写event之外的event的callback </span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">conn_eventcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span> <span class="n">bev</span><span class="p">,</span> <span class="kt">short</span> <span class="n">events</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">user_data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">BEV_EVENT_EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Client端关闭连接 </span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Connection closed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">BEV_EVENT_ERROR</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 连接出错 </span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Got an error on the connection: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="c1">// 如果还有其它的event没有处理，那就关闭这个bufferevent </span>
    <span class="n">bufferevent_free</span><span class="p">(</span><span class="n">bev</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 信号处理event，收到SIGINT (ctrl-c)信号后，延迟2s退出event循环 </span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">signal_cb</span><span class="p">(</span><span class="kt">evutil_socket_t</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">short</span> <span class="n">events</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">user_data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="n">user_data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">delay</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Caught an interrupt signal; exiting cleanly in two seconds.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">event_base_loopexit</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>可以看出，用这种方式写出来的异步非阻塞server的逻辑还是比较容易理解的。</p><p>和协程的实现方式相比，这种方式完全避免了“手工”的上线文切换， 有利于CPU的分支预测的成功率，能发挥CPU处理网络连接的的最大潜能。</p><h2>水平触发LT &amp; 边沿触发ET</h2><p>在struct epoll_event里有连个Flag：EPOLLET和EPOLLLT让初学者很难以理解</p><p>以下是一段关于epoll的man文档：</p><blockquote><p>epoll is a variant of poll(2) that can be used either as an edge-triggered or a level-triggered interface and scales well to large numbers of watched file descriptors. The following system calls are pro- vided to create and manage an epoll instance:</p><ul><li><p>An epoll instance created by epoll_create(2), which returns a file descriptor referring to the epoll instance. (The more recent epoll_create1(2) extends the functionality of epoll_create(2).)</p></li><li><p>Interest in particular file descriptors is then registered via epoll_ctl(2). The set of file descriptors currently registered on an epoll instance is sometimes called an epoll set.</p></li><li><p>Finally, the actual wait is started by epoll_wait(2).</p></li></ul><p>Level-Triggered and Edge-Triggered The epoll event distribution interface is able to behave both as edge-triggered (ET) and as level-triggered (LT). The difference between the two mechanisms can be described as follows. Suppose that this scenario happens:</p><ol><li><p>The file descriptor that represents the read side of a pipe (rfd) is registered on the epoll instance.</p></li><li><p>A pipe writer writes 2 kB of data on the write side of the pipe.</p></li><li><p>A call to epoll_wait(2) is done that will return rfd as a ready file descriptor.</p></li><li><p>The pipe reader reads 1 kB of data from rfd.</p></li><li><p>A call to epoll_wait(2) is done.</p></li></ol><p>If the rfd file descriptor has been added to the epoll interface using the EPOLLET (edge-triggered) flag, the call to epoll_wait(2) done in step 5 will probably hang despite the available data still present in the file input buffer; meanwhile the remote peer might be expecting a response based on the data it already sent. The reason for this is that edge-triggered mode only delivers events when changes occur on the monitored file descriptor. So, in step 5 the caller might end up waiting for some data that is already present inside the input buffer. In the above example, an event on rfd will be generated because of the write done in 2 and the event is consumed in 3. Since the read operation done in 4 does not consume the whole buffer data, the call to epoll_wait(2) done in step 5 might block indefinitely.</p><p>An application that employs the EPOLLET flag should use non-blocking file descriptors to avoid having a blocking read or write starve a task that is handling multiple file descriptors. The suggested way to use epoll as an edge-triggered (EPOLLET) interface is as follows:</p><p>i with non-blocking file descriptors; and</p><p>ii by waiting for an event only after read(2) or write(2) return EAGAIN.</p><p>By contrast, when used as a level-triggered interface (the default, when EPOLLET is not specified), epoll is simply a faster poll(2), and can be used wherever the latter is used since it shares the same semantics.</p><p>Since even with edge-triggered epoll, multiple events can be generated upon receipt of multiple chunks of data, the caller has the option to specify the EPOLLONESHOT flag, to tell epoll to disable the associated file descriptor after the receipt of an event with epoll_wait(2). When the EPOLLONESHOT flag is specified, it is the caller’s responsibility to rearm the file descriptor using epoll_ctl(2) with EPOLL_CTL_MOD.</p></blockquote><p>在epoll的man文档里，我们会看到一个花费大量篇幅描述的两个概念：</p><p>LT（Level Triggered，水平触发） 和 ET（Edge Triggered，边沿触发）</p><p>作者当年花费了九牛二虎之力也没能领悟这段“经文”。后来一个偶然的机会， 一个做电子设计的朋友给我讲明白了其中的道道。</p><p>为了弄明白LT（Level Triggered，水平触发） 和 ET（Edge Triggered，边沿触发）， 我们先要了解，这个Level和Edge是什么涵义，Level翻译成中文这里准确的涵义应该是电平； Edge是边沿。</p><p>这两个词曾经是电子信号领域的一个专有名词。如果，用时序图来标示一个数字电信号“010”， 应该是类似下图所示：</p><img src="https://pic4.zhimg.com/cc7946c9424291a2d1043a2ecad59f23_b.png" data-rawwidth="320" data-rawheight="267" class="content_image" width="320"><br><ul><li>低电平表示0。</li><li>高电平表示1。</li><li>0向1变化的竖线就是上升沿。</li><li>1向0变化的竖线就是下降沿。</li><br><li>在0或者1的情况下触发的信号就是LT（Level Triggered，水平触发）</li><li>在0向1、1向0变化的过程中触发的信号就是 和 ET（Edge Triggered，边沿触发）</li></ul><p>0或1都是一个状态，而0向1、1向0变化则只是一个事件。</p><p>我们很直观的就可以得出结论，LT是一个持续的状态，ET是个事件性的一次性状态。</p><p>二者的差异在于Level Triggered模式下只要某个socket处于readable/writable状态， 无论什么时候进行epoll_wait都会返回该socket；</p><p>而Edge Triggered模式下只有某个socket从unreadable变为readable或 从unwritable变为writable时，epoll_wait才会返回该socket。</p><p>虽然有很多资料表明ET模式的销量会比LT稍高， 但ET模式的编程由于事件只通知一次，很容易犯错误导致程序假死，我们推荐epoll工作于LT模式。 除非你很清楚你选择的是什么。</p><h3>闲话QQ的通信协议</h3><p>如果大家研究过早期的腾讯QQ的通信协议，可以发现QQ的通信协议是基于UDP的。 这点从今天的角度看来显得十分的怪异，因为用UDP这种无连接的协议 实现一套保证消息可靠性的聊天服务的难度是非常之高的。</p><p>了解过那段历史的同学可能知道，当时UDP的确是QQ的唯一选择。 当年QQ达到百万人同时在线的时候，国外的同行还没有认为C10K是个问题。 想要用TCP承担百万人同时在线，在当时的技术条件下恐怕要付出上千台服务器的代价， 这对于当时的"小企鹅"来说是绝对负担不起的一笔投入。</p><p>由于缺乏操作系统对于高性能TCP协议的支持，想要在极为有限的服务器条件下 处理QQ的C1000K问题，UDP的确是当时的腾讯架构师的唯一选择。</p><br><p># 得到授权之前，拒绝任何形式的转载</p></div><div class="entry-content"><h1 style="font-size:25px">网络编程（四）：互联网中TCP Socket服务器的实现过程需要考虑哪些安全问题？</h1><hr>2015-11-12T14:50:22+08:00这篇曾经是答在这里的 <a href="http://www.zhihu.com/question/30507539/answer/48404361" class="internal">互联网中TCP Socket服务器的实现过程需要考虑哪些安全问题？ - auxten 的回答</a><p>最近总是有人问我相关的问题，在专栏补发一下，希望能帮到更多人<br><br></p><p><b>首先，这是个很大的命题，之前在360负责过几个对外的服务的研发，也算是有点小经验，我试着答一下：</b></p><p>在Internet环境下，安全问题我主要分为如下几类：</p><ol><li>信息传输过程中被黑客窃取</li><li>服务器自身的安全</li><li>服务端数据的安全</li></ol><p>首先，如果能用https，就尽量用https，能用nginx等常见服务器，就用常见服务器，主要能避免以下问题：</p><ul><li>自己实现的协议&amp;Server端可能会有各种Bug，被缓冲区溢出攻击等</li><li>SSL加密体系在防监听方面已经足够成熟，值得信赖</li></ul><p>所幸，私有协议服务的攻击需要黑客分析协议，这就给一般的小服务增加了一层保护。但如果是在大公司做事，树大招风，就必须至少做到理论上没有安全漏洞。神马，xor混淆一下，C/S端写死一个对称密钥这种掩耳盗铃的事情就不要做了，不然会死的很难看。</p><p>如果需要自己实现Server端，实现一套合格的SSL还是很考验功底的：</p><ul><li>首先要弄明白SSL加密体系密钥交换的原理</li><li>对各种对称、非对称加密算法要有深刻的理解</li><li>用非对称加密算法怎么实现一套密钥交换体系</li><li>如何处理ca证书，在自签名情况下怎么避免中间人攻击</li></ul><p>工程实现过程中，要考虑：</p><ul><li>各种可能的缓冲区溢出攻击</li><li>SYN flood攻击，慢连接攻击</li><li>DDoS防起来有难度，但至少能防御DoS攻击</li></ul><p>业务逻辑层面，要考虑：</p><ul><li>每个接口都要做好用户&amp;权限验证</li><li>接口会不会被人乱用，重放攻击</li><li>攻击方会不会找到一个比较消耗服务端资源的接口，用很小的代价耗尽服务端资源</li><li>用户的用户名密码会不会被通过接口破解，参见：<a href="http://en.wikipedia.org/wiki/2014_celebrity_photo_hack" class=" wrap external" target="_blank" rel="nofollow noreferrer">2014 celebrity photo hack<i class="icon-external"></i></a></li><li>你的服务会不会被黑客利用去攻击别的服务，特别是会根据用户输入抓取什么资源的服务</li><li>古老的SQL注入</li><li>无耻的仿冒服务，DNS欺诈</li><li>涉及HTML的，还要考虑跨站……</li></ul><p>即使你做到了天衣无缝，还要考虑队友有时会掉链子：</p><ul><li>glibc、openssl这些基础的库也会爆出漏洞，参见：<a href="http://en.wikipedia.org/wiki/Heartbleed" class=" wrap external" target="_blank" rel="nofollow noreferrer">Heartbleed<i class="icon-external"></i></a></li><li>同一台主机上的其它服务被攻陷</li></ul><p>写完之后整个人都不好了<br></p><p>关于加密解密算法参见：<a href="http://zhuanlan.zhihu.com/auxten/20064358" class="internal">加解密（Encryption）&amp; 哈希（Hash）算法----入门指引 - 面向工资编程 - 知乎专栏</a></p></div><div class="entry-content"><h1 style="font-size:25px">网络编程（五）：长连接&连接池的应用</h1><hr>2015-11-17T13:43:01+08:00<h2>长连接&amp;连接池的应用</h2><p>我们知道TCP是基于连接的协议，其实这个“连接”只是一个逻辑上的概念。在IP层看来， TCP和UDP仅仅是内容上稍有差别而已。</p><blockquote><p>TCP的“连接”仅仅是连接的两端对于四元组和sequence号的一种约定而已。</p><br><p>在有些文章里总会提到这名词、或者五元组，甚至七元组。 虽然我很反对摆弄名词秀专业，但我们也要防止被“秀”。 其实很容易理解：</p><ul><li>四元组： 源IP地址、目的IP地址、源端口、目的端口</li><li>五元组： 源IP地址、目的IP地址、协议、源端口、目的端口</li><li>七元组： 源IP地址、目的IP地址、协议、源端口、目的端口，服务类型，接口索引</li></ul></blockquote><p>在性能比较敏感的程序中，为了节省TCP网络调用建立连接三次握手的时间， 很多程序都会选择采用复用之前已经建立过的连接的方法来优化。</p><p>再加上往往是“请求、响应、请求、响应”的模式，单个连接限制了QPS（Query Per Second）的提升。 所以会采取开启多个连接组成一个“池子”的方式来优化性能，我们称之为连接池。</p><h3>HTTP的长连接</h3><p>HTTP长连接，HTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答， 而不是为每一个新的请求/应答打开新的连接的方法。</p><p>在 HTTP 1.0 中, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。 如果浏览器支持 keep-alive，它会在请求的包头中添加：</p><div class="highlight"><pre><code class="language-text">Connection: Keep-Alive
</code></pre></div><p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：</p><div class="highlight"><pre><code class="language-text">Connection: Keep-Alive
</code></pre></div><p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。 这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。</p><p>在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。 HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。</p><p>然而，Apache 2.0 httpd 的默认连接过期时间是仅仅15秒，对于 Apache 2.2 只有5秒。 短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。</p><img src="https://pic3.zhimg.com/9681008dd20be8adab273c8d439c0622_b.png" data-rawwidth="1152" data-rawheight="734" class="origin_image zh-lightbox-thumb" width="1152" data-original="https://pic3.zhimg.com/9681008dd20be8adab273c8d439c0622_r.png"><br><h4>Keep-Alive的优势</h4><ul><li>较少的CPU和内存的使用（由于同时打开的连接的减少了）</li><li>允许请求和应答的HTTP管线化</li><li>减少了后续请求的延迟（无需再进行握手）</li><li>报告错误无需关闭TCP连接</li></ul><h4>Keep-Alive的劣势</h4><p>对于现在的广泛普及的宽带连接来说，Keep-Alive也许并不像以前一样有用。 web服务器会保持连接若干秒(Apache中默认15秒)，这与提高的性能相比也许会影响性能。 对于单个文件被不断请求的服务(例如图片存放网站)，Keep-Alive可能会极大的影响性能， 因为它在文件被请求之后还保持了不必要的连接很长时间。</p><p>根据RFC2616，用户客户端与任何服务器和代理服务器之间不应该维持超过2个链接。 代理服务器应该最多使用2×N个持久连接到其他服务器或代理服务器，其中N是同时活跃的用户数。 这个指引旨在提高HTTP响应时间并避免阻塞。</p><p>但由于，TCP连接减少了，对于静态资源（图片、JavaScript、CSS）较多的网站， 性能反而可能会下降。</p><h4>动静分离</h4><p>为了规避上面说的对图片等静态资源的影响，大多数商业网站会启用独立的静态资源域名。 从而保证主站的动态资源请求和静态资源的请求不会互相挤占连接。</p><p>动静分离同时还会有一个额外的好处：</p><blockquote><p>对于静态资源的请求，HTTP请求头里的Cookie等信息是没有用处的， 反而占用了宝贵的上行网络资源。用独立的域名存放静态资源后， 请求静态资源域名就不会默认带上主站域的Cookie，从而解决了这个问题。</p></blockquote><p>如下表：</p><img src="https://pic3.zhimg.com/01ad604d61e727c65e924a428c4f96f6_b.png" data-rawwidth="642" data-rawheight="372" class="origin_image zh-lightbox-thumb" width="642" data-original="https://pic3.zhimg.com/01ad604d61e727c65e924a428c4f96f6_r.png"></div><div class="entry-content"><h1 style="font-size:25px">庖丁解牛（一）：监控系统</h1><hr>2015-11-19T15:57:58+08:00好朋友“雪糕”是前Baidu的高工，当年我们一起参与构建了一个庞大的运维自动化系统Noah。转载一些他的关于监控系统的感悟，我也深有同感。<p>我们在后来也用Python写了个简易版：<a href="https://github.com/51reboot/rebootMon-4" class=" wrap external" target="_blank" rel="nofollow noreferrer">51reboot/rebootMon-4 · GitHub<i class="icon-external"></i></a></p><p>最近借着出去分享的机会，画了张简化的监控系统架构图：<br></p><img src="https://pic4.zhimg.com/1b3cb6063fa81798d3dda305fc32b8ef_b.jpg" data-rawwidth="529" data-rawheight="605" class="origin_image zh-lightbox-thumb" width="529" data-original="https://pic4.zhimg.com/1b3cb6063fa81798d3dda305fc32b8ef_r.jpg"><p>写在前面<br></p><p>       我从事运维自动化相关的工作，也已经8年了。当初刚开始做的时候，运维开发(devops)这词还不火。很少人知道。国内对运维的理解，也就是机房、服务器、苦逼的7*24小时值班。甚至当时还流传着段子，招运维要人高马大，扛得动服务器。</p><p>      很幸运的主导了两个一线互联网公司的公司级的运维自动化。这俩公司的服务器，都是几十万台级的，IDC都是几十个。很多事情都是摸索着来。一路走来也形成了一些对运维自动化的理解。第一家公司好容易做的七七八八的时候，到第二家实施发现原有的很多理解都被打烂了重新来。但这种经历反而凝练了一些经验。我个人性格原因，不喜欢到外面去讲。偶尔实在没法推辞过去的，也诚惶诚恐的准备，到最后发现很多干货还是没办法一言以蔽之。最后留在外面的都是一些只言片语，不成系统，更不敢说能指导多少。</p><p>      终于下定决心要把我个人的一些理解，通过系列文章来写一写。文笔有限，可能写的不尽人意。也欢迎大家加入运维开发讨论交流群来交流，群号 <strong>365534424 </strong></p><p>废话少说，直接上文。</p><p> 我始终认为监控对于运维来说，犹如眼睛对人来说一样重要。不管说的多么高大上，运维工作里面很大一部分还是响应型的工作。来自于架构调整、服务变更或者来自于监控。说监控是整个运维或者服务生命周期里面最重要的一环都不为过。从事前发现，预警或者故障报警，到事后提供监控现场供回溯追查，监控系统贯穿了运维整个环节。怎么才能有一副好视力，今天我们就来稍微谈谈。</p><p>  正因为监控系统如此重要和通用，所以业内最成熟、最多的产品也是监控系统。商用的、开源的监控系统比比皆是。也有一些很优秀的开源系统应用很广泛。比如Zabbix、cacti、nagios、ganglia等。对于使用开源系统，还是自己开发(相信看这个文章的，应该都不会有购买监控系统的打算)，是使用者自己决定的。业务和团队规模都不足够的时候，直接拿来主义，开源的系统能解决基本问题，性价比高。业务如果后期发展的好，规模快速扩大，复杂度迅速增加的情况下，开源系统就难以为继了。表现在时效性、扩展性、二次开发、支持的服务规模(或者叫系统容量)、良好的权限控制等各方面。</p><p>  从上面几点来看，一个监控系统需要具备的是数据采集、扩展性、告警管理、高可用、历史数据存储与展示、权限管理等几个方面。</p><p>监控本质上就是对被监控对象的状态进行判定。这个监控对象可以是服务器、交换机，也可以是一个几千台服务器的集群，还可以是带宽、CPU利用率，甚至深入到服务内部，监控服务内部的进程、线程、cache命中率等。</p><p>监控对象多种多样，既有实体的，也有虚拟的。 被监控对象的状态进行判定，这句话里面有三个要素。被监控对象、状态、判定。所以监控系统要能够适配足够多的监控对象类型、收集并能转换为可衡量的状态值，才能支持下一步的判定动作。例如，一台服务器上的nginx服务的连接数。服务器上的nginx服务，就是被监控的对象；连接数就是被监控对象的指标，那么状态呢？我们可以定义为，超过1万就是不正常，否则是正常。</p><p>   从这个角度做框，我们来看看监控系统的核心指标都有哪些。首先是能监控的对象范围要越多越好(当然你可以说小而精的也挺美。但维护多套监控系统也是代价)。也就是数据采集，能采集的渠道、支持的方式、采集的指标越多越好。</p><p><b>关于扩展性的定义</b></p><p>       可伸缩性(可扩展性)是一种对软件系统计算处理能力的设计指标，高可伸缩性代表一种弹性，在系统扩展成长过程中，软件能够保证旺盛的生命力，通过很少的改动甚至只是硬件设备的添置，就能实现整个系统处理能力的线性增长，实现高吞吐量和低延迟高性能。</p><p>　　 可伸缩性和纯粹性能调优有本质区别， 可伸缩性是高性能、低成本和可维护性等诸多因素的综合考量和平衡，可伸缩性讲究平滑线性的性能提升，更侧重于系统的水平伸缩，通过廉价的服务器实现分布式 计算；而普通性能优化只是单台机器的性能指标优化。他们共同点都是根据应用系统特点在吞吐量和延迟之间进行一个侧重选择，当然水平伸缩分区后会带来CAP定理约束。</p><br><p><b>可扩展与过度设计的矛盾</b></p><p>        具体讨论到监控系统的可扩展性，我们这里特指系统可以随着被监控对象的规模扩大而无需对架构做大的变更修改。一千台服务器的时候，是这个架构，一万台服务器的时候还是这个架构，最好十万台的时候只需要增加服务器就可以，架构还是那个架构。听起来很棒吧。这也是每个系统架构设计者的梦想。但现实照进理想的时候，发现理想很残酷。首先是对于设计者来说，当他在一家只有几百台服务器规模的公司时，很难去想到自己的系统可能有一天会在跑在几万台的服务器规模上。这里面也有一个架构设计里面的原则，就是要尽量避免过度设计。如果一个几百台服务器规模的公司的运维开发，对他的老板说要做一个系统可以支撑几万台服务器，但因此要多花了多少时间去架构和重构，我想老板会认为自己的运维开发一定是疯了。架构原则之一也是要尽量避免过度设计。</p><p>         但软件设计依然还是推崇良好的架构、良好的可扩展性。否则架构设计的价值就会打很大的折扣，代码复用和系统实现成本会随着规模的扩大而线性增长。良好的架构可以通过迭代得出之后，反过来指导低阶的系统设计。但低阶的无法预测高阶的。这就是架构的用处之一。所以这里稍后我会介绍一下我对于监控系统架构的一些经验和心得。</p><p>        一个称职的设计者，是可以站在几百台服务器的规模时，考虑到几千台的情况的。但他考虑几万台的话就有点过度了。这里并非说能支撑几万台的系统架构不优秀。只是如果他不知道，那也没必要过度考虑。如果能提前知道，甄嬛就会说，那显然是极好的。</p><p>         但很显然需要考虑的内容会越来越多。几十台的时候你可能只需要考虑一个机房了，几百台的时候会有2、3个机房，当几千台的时候可能依然在10个IDC以内，但当几万台的时候很可能已经超过15个IDC了。而且地理位置的分布会更广泛，由此而带来的运营商的覆盖、网络的复杂度、业务的复杂度也会完全不同。非逼着一个运维开发去完全臆想着来做是不现实的。他没有经历过实际的这种需求场景，是没有办法考虑到这样那样的各种问题的。所以我完全理解一些大公司对于开源项目的态度。好一点的可能拿来改改用，进一步可能单独拉一个分支开始改，更甚的就改的完全和主干不一样了 ，其实还有就是自己造轮子的。但有时候就是这样，自己不造轮子，开源的轮子用着的确不好使。</p><p><b>监控的可扩展性</b><br></p><p>        具体到监控系统，可扩展性体现在哪些方面呢？我们从头捋一下。监控系统的输入是监控到的各项监控数据。这些数据经过一系列的处理，最终存储下来用于事后分析和离线分析，同时更主要的作用是要实时的报警。整个这个过程我们可以视为是一个流式计算的过程。说到流式计算其实大家想到的是storm这些。这倒是另外一个我曾经想过的思路，就是把所有处理过程放到strom上去。balabalabala.... 说远了。但我们仔细去看，strom也好，流式计算平台也罢，都是分布式的。分布式架构的一个特性就是良好的扩展性。随着服务器规模的扩大，对于中间的数据处理层的可扩展性要求，就是计算能力要能具备扩展性。简单来说就是数据多了，通过加服务器或者升级服务器就能搞定。</p><p>         还有几个边界的地方需要把扩展性支持好。第一个就是入口。或者叫做数据的接收口。外面的数据源源不断的进入，如果要想做到扩展性良好，第一个需要考虑的就是接收环节。数据可以走TCP、UDP、SNMP、HTTP等多种协议进入到监控系统。考虑到数万服务器的规模，这个地方比较考验技术底子。如果走SNMP、HTTP当然可以，但这两个协议都走在应用层，必然会带来额外的开销。拿HTTP举例子，我们拿Nginx或者apache做server，其实天然带有可扩展性。数据收到以后，存到一个存储即可(不管这个存储是缓存还是永久存储)。这个过程，不带有状态，所以天然具有可扩展性。一个Nginx实例扛不住了，再来一个，再来一个，再来十个。这样就解决了接口的可扩展问题。</p><p>         另外一个可扩展是存储环节。这个存储主要是监控数据的持久化存储。前面我们说，数据接收、计算环节都可以通过一些方式支持可扩展。那存储必然会成为一个瓶颈。这个在很多系统里面都是这样，前端可以通过Web Server实现可扩展，但最终大家都跑到一个数据库上读写。哪怕是读写分离的，还是一个主库。主库压力山大。</p><p>这个地方我推荐用一些分布式存储来解决这个问题。但不是很推荐mango这种比较奇葩的。因为写入的能力不是很好。虽然它后来又有一些改进方案来缓解这个问题，但注意，只是缓解。</p><blockquote><b><u> 综上，对于可扩展性，我们的思路是：分布式、无状态。<br></u></b></blockquote><p>我借用一个高可用性的定义： 高可用性H.A.（High Availability）指的是通过尽量缩短因日常维护操作（计划）和突发的系统崩溃（非计划）所导致的停机时间，以提高系统和应用的可用性。它与被认为是不间断操作的容错技术有所不同。HA系统是目前企业防止核心计算机系统因故障停机的最有效手段。</p><p>      那么高可用，就是高可用性良好的系统。多少算高呢，我以前呆过的BAT某公司喜欢用小数点以后几个9来衡量。当然小数点前面默认就是99。大家普遍认为4个9是还不错的，5个9是核心业务应该具备的。怎么计算呢，这个我后面也可以说一说算法。</p><p>      对于运维工程师来说，要是能运维一个可用性非常高的系统，我想是一件幸事。系统能高可用，运维处理报警的优先级就不用那么高了。大冬天晚上收个报警，也不用立刻从被窝里面爬起来连VPN处理了。可用性越高，运维工程师睡觉越安心。</p><br><p><strong>影响高可用的因素与计算方式</strong><br></p><p>      影响可用性的因素都有哪些？让我们来捋捋。一个服务分为软件、硬件。拿一个网站来解解。</p><p>      假设有个网站，域名是<a href="http://www.51reboot.com" class=" wrap external" target="_blank" rel="nofollow noreferrer">Reboot教育 - 高效你的学习<i class="icon-external"></i></a>。部署了一个nginx，部署在一台服务器上，这台服务器在一个叫做zw的电信机房。</p><p>      用户从浏览器输入<a href="http://www.51reboot.com" class=" wrap external" target="_blank" rel="nofollow noreferrer">Reboot教育 - 高效你的学习<i class="icon-external"></i></a>开始，直到他在浏览器上能打开这个网页内容为止，有哪些步骤？</p><p>      第一步，域名解析</p><p>      第二步，向着服务器发起HTTP请求</p><p>      第三步，请求走网络，到达服务器所在机房的交换机</p><p>      第四步，数据走几层交换机之后，到达服务器网卡</p><p>      第五步，网卡数据经过OS，到达Nginx</p><p>      第六步，Nginx收到HTTP请求</p><p>      第七步，Nginx调用ThinkPHP框架(这里假定是这个框架)</p><p>      第八步，PHP连接Mysql数据库获取数据</p><p>      第九步，PHP处理数据</p><p>      第十步，Nginx返回数据到用户端</p><p>      第十一步，用户端浏览器完整接收数据之后，渲染完毕</p><p>      粗略的分，11个步骤。这里涉及：DNS、服务器、交换机、OS、Nginx、ThinkPHP、PHP、Mysql</p><p>服务器又可以分为：磁盘，以及其它部件如CPU、内存。之所以这样分，是因为磁盘作为存储部件是最容易坏的一个部件。</p><p>      好了，我们接下来算一算，51reboot这个网站的可用性是多少。一次可用，相当于上面的十一个步骤都得正常才叫可用。那么就要考虑了，DNS的可用性是多少，服务器不宕机(可用性)是多少、Nginx之类的软件的可用性是多少、Mysql、磁盘的可用性是多少、网络的可用性是多少等等。这些可用性的乘积，就是该网站的可用性。</p><p>      这里还没有考虑更多实际情况。比如，mysql如果和web端不在同一台机器上、甚至不在同一个机房，或者部署的nginx实例不止1个，等等。</p><p>      上面我们讲了可用性怎么计算。下面我们来看看监控系统的高可用。</p><br><p><strong>先定性，再定量</strong></p><p>      这是我的原则，事情都是先定性，看是否有必要，再定量，看需要定到多少，具体量化。监控系统本身是监控别的服务和系统是否正常运行的。如果监控系统自身可用性不足，会严重影响监控效果。甚至可以说就是没有什么用处，有大隐患。</p><p>      这里还涉及了另外一个问题，就是监控系统自身的监控。以后会开篇幅来讲。</p><p>      前面说了，监控系统本身必须高可用。那下面我们就看这个高可用需要怎么量化。读者觉得应该达到小数点之后几个9？我个人觉得至少2个9.也就是99.99%。否则业务部门的兄弟们急了，因为他们的系统如果要求是99.999%，没人能证明啊。监控系统本身才是99.99%。</p><p><strong>如何达到高可用99.99%</strong></p><p>      这是今天这篇要讨论的另外一个核心问题了。要达到高可用性，还要看系统的架构。按照有没有单点来区分，系统有两类，一类是有单点的架构，一类是没有单点的架构。讲到这里我们有必要说一下什么叫做单点。单点简单来说就是系统里面的某个部位，它在系统里面部署的时候，是一个唯一存在。这个唯一存在不能扩展性的部署一个兄弟实例出来。这种唯一存在将来就最有可能是系统里面的老大难，因为它出了问题，没有兄弟能顶上。</p><p>      但，我又要说但是了。没有单点，不代表说完全百分之百的没有问题。例如，我们采用Hash的办法，负载均衡的方式，部署了2个Nginx实例。当其中一个实例挂掉的时候，仅影响了50%的请求。不能算整个系统挂掉了。但这个系统的稳定性依然堪忧，我们不能说它的可用性有多高。 如果Hash计算能够结合了实例的健康状态，不健康的自动从hash计算的池子里面摘掉，那可用性就大大提升了。</p><p>      综上，以及综合我们上一篇，监控系统要想达到高可用，必须要采用去中心化的架构来做。就是让整个系统里面没有任何一个环节是单点。因为单点就意味着瓶颈，意味着可用性提升很难很复杂，不容易做高。</p><p>      具体说说，怎么才能去单点。我们从监控系统本身的数据流来分析。</p><p>      数据采集，这个要分类来说。一个是带内的，跑在OS上的代理Agent。这个的高可用，是另外一个领域的事情，就是怎么写一个高可用的、鲁棒性非常好的客户端。我们以后分开篇幅说。</p><p>      另外是带外的。比如，HTTP或者端口监控，或者存活监控。我们拿存活监控来举例吧。比如说，我们通过ping的方式，来监控服务器是否存活。那么我们需要一个批量发ping包的探测器。这个也是一个数据采集端。只是没有在OS上来采集。当然它也存在鲁棒性的问题，但这是另外一个领域的事情，我们这一篇不谈。这个客户端，如果它挂了，可想而知，被它监控的服务器都失去监控了。所以我们要提高Ping监控模块或者叫环节的可用性。一个最简单办法，我们用两个监控点来监控同一批服务器。但新的问题又来了，俩监控点监控同一台服务器，什么情况下可以断定这个服务器挂了呢？这个是另外一个监控数据合并的问题，我们也放到以后的篇章里面去讨论。 另外一个提高可用性的办法，就是ping监控点部署两个，但两个之间不要同时生效，但两个节点之间有心跳，一个挂了，另外一个接管，也是一个办法，但切换略复杂。</p><p>      数据采集回来了，要做处理。这个处理或者叫计算环节的高可用，有不少现成的办法。第一，部署两个计算实例，但两个实例需要能互备或者同时发挥作用。第二，纯分布式办法。</p><p>      存储和Web的分布式方案就更多了。</p><p>      还有一个最关键的地方，如何实现无状态。只有无状态了，才能达到简单的部署切换，就可以支撑高可用。这个问题我们留待之后来讲。</p><p>架构这个词太大了，这里我们缩小一下，只来谈谈宏观的监控系统整体架构。在这个范围里面，web由于负责统一的系统管理和操作功能，缩减为一个模块。</p><p>最简单的架构如下图</p><img src="https://pic4.zhimg.com/8a31914d324b6b8462ccdc5541c7989f_b.jpg" data-rawwidth="379" data-rawheight="568" class="content_image" width="379"><br><p>这是监控系统第一层的架构。比照百度地图的话，我们可以认为这个是全国地图。最粗粒度的几个模块就是这三个。web、数据采集、数据处理。</p><br><p><strong>PUSH  PULL</strong></p><p>我们先来关注数据采集模块到数据处理和报警模块的这个环节</p><p>     推和拉，技术选型里面常常遇到的一个选择题。 在Client/server结构中，信息获取方式是按“拉”（Pull）的模型进行的：服务器根据用户终端发送的服务请求进行处理并返回用户所需 的结果。在Push模型中，服务器把信息“推”给Client。虽然两者数据传输的方向都是从服务器流向Client，但操作的发起者是不同的。从“信源”与“用户”的关系来看，信息的流动可分为两种模式，即信息推送与信息拉取模式。</p><p>      两种模型的对比见表格<br><img src="https://pic3.zhimg.com/fadf86c6738e3b9d7c154dd5a5f3366a_b.jpg" data-rawwidth="477" data-rawheight="367" class="origin_image zh-lightbox-thumb" width="477" data-original="https://pic3.zhimg.com/fadf86c6738e3b9d7c154dd5a5f3366a_r.jpg"></p><br><p>     其中PUSH的好处是及时性好。但缺点是服务端要有比较复杂的状态管理。同时在到达率等方面都会有一些纠结的地方。而PULL的好处则是服务端简单，状态管理简单，但缺点是时效性上不可控。体现在监控系统上，如果所有要监控的监控项，都是需要Server端PUSH给Client，假设Client所在服务器关机了，那PUSH的时候就是不可达的。Server端就得想办法记录下来，并且再做重试等失败处理。而如果是Client端主动来PULL就好办了，服务器开机启动之后，Client立刻来拉取。到达率肯定要好，对Server的管理也简化了。但缺点就是想生效一个监控项，只能等着Client来PULl，而无法立即生效。</p><p>       这里还有一个比较经典的例子，也是我面试别人的时候总喜欢问的一个问题。当然我问面试者的时候主要是想去看看TA的逻辑思维能力。</p><p><strong>题目：</strong>微博大家都用过。里面你可以关注一个人，也可以被人关注。当你发一条微博时，关注你的人都会收到一条提示。当你关注的人发一条微博时，你会收到一条提示。 请问这个提示，是PUSH 还是 PULL到你的微博客户端(浏览器或者手机微博)上的?</p><p><strong>面试者：</strong>肯定会有人说，PUSH呗。</p><p><strong>面试官：</strong>OK，然后我就会问了，姚晨在新浪微博上的粉丝数是5000多万，她发一条微博，是不是得PUSH 5000多万个消息到各个账号去？</p><p><strong>面试者：</strong>额，那就是定时PULL </p><p><strong>面试官：</strong>确定吗？几千万个客户端都PULL？</p><p><strong>面试者：</strong>额。。。 面试者开始额头黑线了。</p><p><strong>面试官：</strong>请问该怎么办？</p><p>    PUSH的话，姚晨的一条微博，在系统里面就要产生5000万条消息要处理。如果她一天发个100条，估计新浪微博疯了。这还没有考虑很多客户端不登陆，消息就得缓存着。还有很多客户端一下子通知不到，还得处理失败。</p><p>PULL的话，如果大量用户在使用的生产系统，对存储和缓存是一个很大的挑战。</p><p>具体的，大家可以再去google一下，这个事情其实有很多方案。</p><p><strong>经验比较丰富的研发一定会同意我的一个说法：两个争论不休的技术方案，最终能达成一个融合了二者的第三个方案。</strong>就好像两个特别对立的谈判方，到最后谈判结果是一个融合或者叫妥协的方案。PUSH和PULL也可以二者融合，将做到取长补短，使二者优势互补。根据推、拉结合顺序及结合方式的差异，又分以下四种不同推拉模式：</p><ul><li><p>先推后拉——先由服务端PUSH，再由Client端有针对性地拉；</p></li><li><p>先拉后推——根据Client端PULL的信息，服务端进一步主动PUSH与之相关的信息；</p></li><li><p>推中有拉——在数据推送过程中，允许Client随时中断并PULL更有针对性的信息；</p></li><li><p>拉中有推——根据Client端PULL的过程，Server主动推送相关的最新信息</p></li></ul><br><p><strong>几个开源监控系统的PUSH PULL选择</strong></p><p>zabbix ： 带agent方式。agent主动推送数据到服务端。 从client的角度看，是PUSH数据到Server</p><p>Cacti    :   SNMP协议，无Client，或者说Client是SNMP Client.  从Client角度看，是PULL</p><p>ganglia： 从Client角度看，是PUSH</p><p>在我过去生产环境所构造的监控系统里面，我们采用了PUSH 和PULL结合的方式来达到及时性、到达率的同时解决。我们站在Client的角度来描述这个解决方案。对于监控项的生效，web端变更之后立即使用PUSH的方式来通知Client。但这里一定有达到率的问题。比如Client所在服务器死机了、重启了、当时网络有问题不可达了等等。所以我们在Client端，支持定时PULL。定时去主动联系Server端，获取自己应该生效的监控内容。</p><br><p><strong>HASH</strong></p><p>怎么突然又说到HASH了呢。 HASH先来个概念普及吧。看完概念还是不了解的同学，自行面壁去，你计算机数据结构一定没好好学。</p><p>我说HASH是因为要为后面介绍高可用性架构有关系的。</p><p>HASH你别直接拿去搜，用百度的结果就是哈士奇。</p><p>关键词可以是哈希。</p><p> Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>Hash在算法里面是很基础但使用非常广泛的。特别是在大数据量的情况下。</p><p>我这里强调Hash，是想说它的一个作用之一就是散列。把输入散列到几个地方去。提到Hash不得不提一个词叫做一致性Hash，这个算法对于解决缓存命中率有很大好处。在内存缓存、CDN等存储系统中经常使用。</p><p>Hash的精髓之一就是按照某种计算规则，把输入散列到不同的输出通道上去。</p><br><p><strong>无状态和有状态</strong></p><p>我们拿无状态协议来体验一下无状态是个什么概念。</p><p>协议的状态是指下一次传输可以“记住”这次传输信息的能力。典型的如HTTP协议是不会为了下一次连接而维护这次连接所传输的信息,</p><p>由于Web服务器要面对很多浏览器的并发访问，为了提高Web服务器对并发访问的处理能力，在设计HTTP协议时规定Web服务器发送HTTP应答报文和文档时，不保存发出请求的Web浏览器进程的任何状态信息。这有可能出现一个浏览器在短短几秒之内两次访问同一对象 时，服务器进程不会因为已经给它发过应答报文而不接受第二期服务请求。由于Web服务器不保存发送请求的Web浏览器进程的任何信息，因此HTTP协议属 于无状态协议（Stateless Protocol）。</p><br><p><strong>监控系统里面的HASH和状态</strong></p><p>监控系统对数据的处理，主要是过滤异常数据出来并报警。比如某个服务器的CPU利用率超过了95%，需要报警。但这个时候突然数据处理模块所在服务器宕机了。那么这个异常数据很有可能就丢掉了。</p><p>监控系统常见的报警条件是： CPU利用率超过95%，算一次异常。如果5分钟内有3次异常，报警给运维。</p><p>这里就有几个数字需要处理，5分钟，3次。前面提到的宕机，会导致一次异常数据丢掉了。假设5分钟内出现了3次，丢掉了一次，那自然不会报警出来。这就是一个有状态的场景。</p><p>有状态的情况下，做自动切换或者负载均衡，需要把状态也带过去才行。</p><p>比较典型的还有session的问题。如果web是多台主机负载均衡的时候，session存本地是会出问题的。因为用户有可能通过负载均衡的调度，多次请求落在不同的主机上。 本来HTTP协议是无状态的，支持负载均衡的调度。但因为session这个有状态的产物，必须要把session放在公共存储上才行。</p><p>结合前面提到的那个架构图。数据进入到了数据计算和报警模块。我们如何保证这个数据计算和报警模块是个高可用的架构。</p><p>答案是，把输入的监控数据Hash到不同的数据计算和报警模块实例上去，并且最好是无状态或者弱状态的计算过程。</p><br><img src="https://pic1.zhimg.com/1b0356dd0fec3d4d9031d41c335ad754_b.jpg" data-rawwidth="430" data-rawheight="430" class="origin_image zh-lightbox-thumb" width="430" data-original="https://pic1.zhimg.com/1b0356dd0fec3d4d9031d41c335ad754_r.jpg"><p><b>本文原载于： <a href="http://opsdev.blog.51cto.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Reboot运维开发<i class="icon-external"></i></a> 。作者书面授权发表，拒绝任何形式的转载。</b></p><p><strong>欢迎大家加入运维开发讨论交流群来交流，群号 <strong>365534424，本文仅授权51reboot、51cto、知乎auxten专栏 上发布。</strong></strong></p></div><div class="entry-content"><h1 style="font-size:25px">网络编程（六）：端口那些事儿</h1><hr>2015-11-24T20:01:26+08:00<h2>TCP和UDP协议都存在一个叫做端口的东西，但端口却不是IP协议的一部分。<br></h2><p>端口被设计出来主要是为了给协议栈和应用对应：</p><ul><li>协议栈用端口号将数据分配给不同的应用层程序</li><li>应用层程序用端口号去区分不同的连接，参见之前提到过的“四元组”</li></ul><p>TCP和UDP协议都使用了端口号（Port number）的概念来标识发送方和接收方的应用层。 对每个TCP连接的一端都有一个相关的16位的无符号端口号分配给它们。 即使是UDP这种没有连接的协议，依旧有一个16位的无符号端口号。 可能的、被正式承认的端口号有 2^16 -1 = 65535 个。</p><h3>三类端口</h3><p>端口被分为三类：著名端口、监听端口和动态端口。</p><ul><li><p>著名端口是由因特网赋号管理局（IANA）来分配的，并且通常被用于系统进程。 IANA对于端口号的分配见这里 <a href="http://www.iana.org/assignments/port-numbers" class=" wrap external" target="_blank" rel="nofollow noreferrer">Service Name and Transport Protocol Port Number Registry<i class="icon-external"></i></a> 。 系统的/etc/services也有相应端口和服务名的对应，主要是用来给netstat、nmap 等系统命令做端口名反解用。</p><p>著名的应用程序作为服务器程序来运行，并侦听经常使用这些端口的连接。 这些端口的一个显著特征就是限定在0~1023，并且在Linux、UNIX平台均需要 Root权限才能监听这些端口。</p><p>在UNIX刚刚兴起的年代，服务器资源是十分稀缺的， 通常一台服务器上会有很多的用户，同时这台服务器往往还兼任一个学院、公司的邮件、 网站等服务。为了保证这些服务的端口不被普通用户占用， 当时UNIX的设计者就把使用这些端口的权限限制在系统管理员(Root)手里。</p><div class="highlight"><pre><code class="language-text">常见的`著名端口`有：FTP:21、SSH:22、SMTP:25、HTTP:80、HTTPS:443等。
</code></pre></div></li><li><p>监听端口通常被用来运行各种用户自己写的服务，服务监听在这些端口下不需要特别的权限。</p><ul><li>BSD使用的监听端口范围是1024到4999。</li><li>IANA建议49152至65535作为“监听端口”。</li><li>许多Linux内核使用32768至61000范围。 配置文件 /proc/sys/net/ipv4/ip_local_port_range 有当前系统设定。</li></ul></li><br><li><p>动态端口通常被用来在主动发起连接时随机分配使用，在任何特定的TCP连接外不具有任何意义。 这是由于TCP等协议是通过四元组来区分不同的网络连接。 当本机主动发起TCP连接的时候如果目的IP、目的端口、本地IP都是一样的， 只能通过占用不同的本地端口来区分不同的连接。</p><p>0~65535除去上述著名端口、监听端口两种端口号，剩下的端口都是备用的动态端口。 所以在某些特殊用途的需要主动发起大量连接的服务器上（例如：爬虫、代理）， 需要调整 /proc/sys/net/ipv4/ip_local_port_range 的数值，来保留更多的 动态端口以供使用。</p></li></ul><h3>0号端口</h3><p>端口号里有一个极为特殊的端口，各种文档书籍中都鲜有记载，就是0号端口。</p><p>在IANA官方的标准里0号端口是保留端口。</p><img src="https://pic1.zhimg.com/64916d0b0829d89e8465b140b5c4b744_b.png" data-rawwidth="1012" data-rawheight="154" class="origin_image zh-lightbox-thumb" width="1012" data-original="https://pic1.zhimg.com/64916d0b0829d89e8465b140b5c4b744_r.png"><p>也就是说无论是TCP还是UDP网络通信，0号端口都是不能使用的。</p><p>然而，标准归标准，在UNIX/Linux网络编程中0号端口被赋予了特殊的涵义：</p><div class="highlight"><pre><code class="language-text">如果在bind绑定的时候指定端口0，意味着由系统随机选择一个可用端口来绑定。
</code></pre></div><p>用Python实现一个获取可用监听端口的示例：</p><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">findFreePort</span><span class="p">():</span>
  <span class="sd">"""</span>
<span class="sd">  函数返回值是当前可用来监听的一个随机端口。</span>
<span class="sd">  """</span>
  <span class="kn">import</span> <span class="nn">socket</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s">'localhost'</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
  <span class="c"># 用getsockname来获取我们实际绑定的端口号</span>
  <span class="n">addr</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()</span>
  <span class="c"># 释放端口</span>
  <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">port</span>
</code></pre></div><h3>网络地址转换NAT</h3><p>既然说到了端口，不得不提一下NAT。</p><p>NAT是"Network Address Translation"的缩写，直译就是网络地址转换。 1990年代中期，为了应对IPv4地址短缺，NAT技术流行起来。</p><p>WikiPedia的解释为：</p><blockquote><p>在一个典型的配置中，一个本地网络使用一个专有网络的指定子网 （比如192.168.x.x或10.x.x.x）和连在这个网络上的一个路由器。 这个路由器占有这个网络地址空间的一个专有地址（比如192.168.0.1）， 同时它还通过一个或多个因特网服务提供商提供的公有的IP地址（叫做“过载”NAT） 连接到因特网上。当信息由本地网络向因特网传递时，源地址被立即从专有地址转换为公用地址。 由路由器跟踪每个连接上的基本数据，主要是目的地址和端口。当有回复返回路由器时， 它通过输出阶段记录的连接跟踪数据来决定该转发给内部网的哪个主机； 如果有多个公用地址可用，当数据包返回时，TCP或UDP客户机的端口号可以用来分解数据包。 对于因特网上的一个系统，路由器本身充当通信的源和目的地址。</p></blockquote><p>这个技术能够被广泛使用还要感谢当时端口号的记录字段是2Bytes而不是1Byte。</p><p>NAT技术的广泛应用也给很多应用带来了极大的麻烦： 处于NAT网络环境内的服务器很难被外部的网络程序主动连接，受这一点伤害最大的莫过于： 点对点视频、语音、文件传输类的程序。</p><p>当然我们聪明的工程师经过长时间的努力，发明了“NAT打洞”技术，一定程度上解决了此类问题。</p><p>如果没有他们的努力，我们现在各种QQ视频、微信实时语音、网络电话都是需要用户连接到 服务商的服务器上进行数据传输。这样对服务商的网络消耗将是十分巨大的， 服务质量也是很难以提高的，具体的技术实现，我们以后再表。</p><h3>多进程端口监听</h3><p>我们都有一个计算机网络的常识：不同的进程不能使用同一端口。</p><p>如果一个端口正在被使用，无论是TIME_WAIT、CLOSE_WAIT、还是ESTABLISHED状态。 这个端口都不能被复用，这里面自然也是包括不能被用来LISTEN（监听）。</p><p>但这件事也不是绝对的，之前跟大家讲进程的创建过程提到过一件事： 当进程调用fork(2)系统调用的时候，会发生一系列资源的复制，其中就包括句柄。 所以，在调用fork(2)之前，打开任何文件，监听端口产生的句柄也将会被复制。</p><p>通过这种方式，我们就可以达成"多进程端口监听"。</p><p>但，这又有什么用呢？</p><p>我们大名鼎鼎的Nginx就是通过这种手法让多个进程同时监听在HTTP的服务端口上的， 这么做的好处就在于，当外部请求到达，Linux内核会保证多个进程只会有一个accept(2) 成功，这种情况下此端口的服务可用性就和单个进程存在与否无关。 Nginx正是利用这一点达成“不停服务reload、restart”的。</p><h3>SO_REUSEADDR</h3><p>要说SO_REUSEADDR，我们需要先需要说一段历史： 记得大学的时候面试我们学校的“星辰工作室”，有一个问题就是</p><div class="highlight"><pre><code class="language-text">为什么有时候重启Apache会失败，报“Address already in use”？
</code></pre></div><p>当时答得不太好，不太明白这个问题的关键点在哪里，后来逐渐明白了。</p><p>TCP的原理会导致这样的一个结果：</p><p>主动close socket的一方会进入TIME_WAIT，这个状况持续的时间取决于三件事：</p><ul><li>TCP关闭连接的五次挥手包什么时候到达</li><li>SO_LINGER的设置</li><li>/proc/sys/net/ipv4/tcp_tw_recycle 和 /proc/sys/net/ipv4/tcp_tw_reuse 的设置</li></ul><p>总之默认情况下，处于TIME_WAIT状态的端口是不能用来LISTEN的。 这就导致，Apache重启时产生80端口TIME_WAIT，进而导致Apache再次尝试LISTEN失败。</p><p>在很多开源代码里我们会看到如下代码：</p><div class="highlight"><pre><code class="language-c"><span class="kt">int</span> <span class="n">reuseaddr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reuseaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></div><p>有了上面这段神奇的代码，就不会出现上面的惨剧。但SO_REUSEADDR的作用不仅限于上述</p><p>Linux 的 SO_REUSEADDR 设置为 1 有四种效果：</p><ol><li><p>当端口处在TIME_WAIT时候，可以复用监听。</p></li><li><p>可以允许多个进程监听同一端口，但是必须不同IP。</p><blockquote><p><strong>这里说的比较隐晦，如果进程A监听0.0.0.0:80，B进程可以成功监听127.0.0.1:80， 顺序反过来也是可以的。</strong></p></blockquote></li><li><p>允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的IP地址不同。</p></li><li><p>使用UDP时候，可以允许多个实例或者单进程同时监听同个端口同个IP。</p></li></ol><br><br><p>服务端网络编程交流群：<b>348904670</b><br></p><p><b>公众号：</b></p><img src="https://pic3.zhimg.com/91730ff8713adb3fb80d79dba4beb3de_b.jpg" data-rawwidth="344" data-rawheight="344" class="content_image" width="344"><br><p><u># 得到书面授权之前，拒绝任何形式的转载</u></p></div><div class="entry-content"><h1 style="font-size:25px">庖丁解牛（二）：360集群控制系统概述</h1><hr>2015-11-30T12:00:17+08:00<h2>如何在5s之内控制5w台服务器执行命令</h2><p>之前在360主导设计了360的服务器集群控制系统，当时由于保密原因，没有机会在外面讲一下，现在终于有机会，希望能给大家一点借鉴。</p><h4>什么是控制系统</h4><ul><li>快速，安全的进行服务器任务分配。</li><ul><li>最终达到的性能指标是5s对30000台服务器进行任务分发&amp;执行&amp;结果获取</li></ul><img src="https://pic3.zhimg.com/6c866a22da728b7c7655ec7c63bb3ea2_b.png" data-rawwidth="1576" data-rawheight="1020" class="origin_image zh-lightbox-thumb" width="1576" data-original="https://pic3.zhimg.com/6c866a22da728b7c7655ec7c63bb3ea2_r.png"></ul><li>用要求的权限进行执行，精确控制任务</li><ul><li>严格的权限树限制<ul><li>插件审核机制</li><li>用户只能操作自己有权限的树节点</li></ul></li><li>agent控制信道加密(对称加密算法 with salt)</li><li>能在任务执行的任何时间进行 暂停、继续、停止<ul><li>仅限于子任务（机器）粒度</li></ul></li><li>HTTP回调接口<ul><li>如果在创建任务时提供一个HTTP URL，子任务（机器粒度）的任何状态变化都会通过这个回调进行通知</li></ul></li><li>对任务的输出，返回值进行收集，汇总，入库</li></ul><br>控制系统架构<br><p>由于我们的控制系统属于基础服务，一般来说我们对公司的一般业务的可用性要求是要达到99.99%。作为基础架构类的服务必须比普通业务的可用性要高1~2个数量级，也就是：99.999%~99.9999%。</p><p>所以，一个最基本的要求就是，整套系统必须没有任何单点。</p><p>我们整套系统的架构图如下： <br></p><img src="https://pic2.zhimg.com/1ffe968cced368a683cca30fa27077b9_b.jpg" data-rawwidth="725" data-rawheight="710" class="origin_image zh-lightbox-thumb" width="725" data-original="https://pic2.zhimg.com/1ffe968cced368a683cca30fa27077b9_r.jpg"><br><p>我们为了达到这一点，我们做了如下设计：</p><ol><li>我们的控制系统本身没有任何状态，任何状态都是保存在数据库中。</li><li>我们单独设计了一个hermes-sitter模块， 负责健康检查以及在健康检查失败的时候进行必要的触发错误逻辑。</li></ol><p>整套系统在各种情况下的故障恢复逻辑如下图所示：</p><img src="https://pic3.zhimg.com/007de4d9c3b3af55fcf19b848a410ae2_b.jpg" data-rawwidth="1500" data-rawheight="2037" class="origin_image zh-lightbox-thumb" width="1500" data-original="https://pic3.zhimg.com/007de4d9c3b3af55fcf19b848a410ae2_r.jpg"><p>整套系统的开发是在我们详细分析并绘制了上述图表的情况下给出的， 所以整体的Coding时间也只用了一周，在加上我们用gtest做的较为详尽的单元测试 由于各种错误检查的逻辑在里面，最后的单侧行覆盖率也就在70%左右， 系统上线后3年，仅修复了一处关于暂停点的bug。</p><h4>控制系统的实现细节</h4>第三方库的应用<p>我们在构建控制系统的时候主要应用的第三方库有：</p><ul><li>libev<ul><li>著名网络事件库libevent的弟弟，更轻，更快</li></ul></li><li>c-ares<ul><li>异步DNS解析库，对DNS over TCP的支持，提高响应速度</li><li>由于只对select模型提供了支持，我们给它加了个patch来配合libev使用</li></ul></li><li>gtest<ul><li>google的单测框架</li><li>单测是一种很好的在软件构建初期就可以发现潜在的bug的方法</li></ul></li></ul>网络模型<ul><li>我们的网络模型是参考memcached的线程模型，对等多线程模型<ul><li>对client模型和server模型都给予很好的支持</li><li>“对等”不会由于线程分工造成性能瓶颈，减少内存拷贝</li></ul></li></ul><p>代码地址：<a href="https://github.com/auxten/gko_pool" class=" wrap external" target="_blank" rel="nofollow noreferrer">auxten/gko_pool · GitHub<i class="icon-external"></i></a></p>内存分配优化<p>在项目优化的后期，我们发现内存分配是我们系统的一个性能瓶颈， 为此，我们特意构建了一个比较专用的内存池。</p><p>主要针对我们在创建连接之前所要开辟的国定大小的内存进行加速。</p><p>主要目的有如下两点：</p><ul><li>减少为每个连接分配初始的r/w buf的开销</li><li>实现了一个简单的内存池，只能分配4K块大小的内存块，bucket大小可以配置，stupid but works</li></ul><p>代码地址：<a href="https://github.com/auxten/gkoAlloc" class=" wrap external" target="_blank" rel="nofollow noreferrer">auxten/gkoAlloc · GitHub<i class="icon-external"></i></a></p>瓶颈发现与解决<p>经过我们利用gpreftools的寻找性能瓶颈，我们发现DNS成为我们系统最大的瓶颈。</p><p>我们尝试过用多线程DNS解析，但收效甚微，就像这样：</p><img src="https://pic1.zhimg.com/2f3a61c9b33ce5237e73cdd6c278b3cc_b.png" data-rawwidth="499" data-rawheight="322" class="origin_image zh-lightbox-thumb" width="499" data-original="https://pic1.zhimg.com/2f3a61c9b33ce5237e73cdd6c278b3cc_r.png"><br><p>然后，我们又很自然的想到，可以使用DNS Cache来解决。</p><p>但是，遇到不能解析正确的域名，我们还是需要走DNS查询，还是弱爆了， 就像这样：</p><img src="https://pic4.zhimg.com/21a123db698161700ca01654271299a3_b.jpg" data-rawwidth="499" data-rawheight="322" class="origin_image zh-lightbox-thumb" width="499" data-original="https://pic4.zhimg.com/21a123db698161700ca01654271299a3_r.jpg"><br><p>我们需要一个突破性的解决方案，像这样的：</p><img src="https://pic4.zhimg.com/5714158a254370e629f97119b2205bfb_b.jpg" data-rawwidth="450" data-rawheight="336" class="origin_image zh-lightbox-thumb" width="450" data-original="https://pic4.zhimg.com/5714158a254370e629f97119b2205bfb_r.jpg"><br><p>首先，需要解释一个问题，我们的控制系统由于一些特殊的网络ACL限制原因设计成了：</p><blockquote><p>由我们的中心控制端主动发起连接去连接我们的agent</p></blockquote><p>这点，也让我们的控制系统成为了一个在普通服务端工程中比较少见的高性能"客户端"编程模型。</p><p>一般来说，"服务端"编程模型的特征是：监听在一个端口上等待连接的到来</p><ul><li>服务端编程模型的流程伪代码是这样的：<br></li><ul><li>短连接：</li></ul></ul><div class="highlight"><pre><code class="language-python"><span class="n">bind</span><span class="err">端口</span>
<span class="n">listen</span><span class="err">监听等待连接</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="n">accept</span><span class="err">新连接</span>
  <span class="n">read</span><span class="err">请求数据</span>
  <span class="err">处理业务逻辑</span>
  <span class="n">write</span><span class="err">响应数据</span>
  <span class="n">close</span><span class="err">连接</span>
</code></pre></div><ul><ul><li>长连接：</li></ul></ul><div class="highlight"><pre><code class="language-python"><span class="n">bind</span><span class="err">端口</span>
<span class="n">listen</span><span class="err">监听等待连接</span>
<span class="n">accept</span><span class="err">新连接</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="n">read</span><span class="err">请求数据</span>
  <span class="err">处理业务逻辑</span>
  <span class="n">write</span><span class="err">响应数据</span>
</code></pre></div><p>而"客户端"编程模型的特征：调用connect(2)来主动发起连接：</p><p>短连接：</p><div class="highlight"><pre><code class="language-python"><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="n">connect</span><span class="err">发起连接</span>
  <span class="n">write</span><span class="err">请求数据</span>
  <span class="n">read</span><span class="err">响应数据</span>
  <span class="n">close</span><span class="err">连接</span>
</code></pre></div><p>长连接：</p><div class="highlight"><pre><code class="language-python"><span class="n">connect</span><span class="err">发起连接</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="n">write</span><span class="err">请求数据</span>
  <span class="n">read</span><span class="err">响应数据</span>
</code></pre></div><p>我们的控制系统就属于"客户端高并发短连接"编程的一个很好的实例。</p><p>客户端网络编程里大家容易忽略，也是glibc给大家无意间误导的就是：DNS查询也是一个 请求&amp;响应的网络操作。</p><p>通常情况下，DNS都是基于UDP，请求和响应都是各自一个UDP数据包就可以完成的。 其速度也是非常快的。但由于DNS查询是一个递归的过程，如果一个DNS域名查询的请求在第一次请求的DNS服务器中没有被找到，DNS服务器就会询问上层DNS……依次递归。</p><p>这样就会导致当查询的域名为不存在的域名的时候就格外的费时，在异步非阻塞的main loop 中这种费时是致命性的。</p><p>所以，我们的解决方案是：</p><blockquote><p>包括DNS在内，全异步 libev + 状态机 + c-ares</p></blockquote><p>经过我们的异步DNS改造，这个问题被完美的解决。</p><p>相关网络框架代码参见：<a href="https://github.com/auxten/gko_pool" class=" wrap external" target="_blank" rel="nofollow noreferrer">auxten/gko_pool · GitHub<i class="icon-external"></i></a></p>易用性改造<p>为了安全性考虑，我们没有直接的把bash命令调用的功能直接开放给用户。</p><p>因为，我们的控制系统是可以在5s之内给6万台主机下发命令的， 所以，如果发生误操作那影响也是相当大的。</p><p>我们只允许用户调用审核过的插件进行任务执行。</p><p>为了让我们的系统更容易的接入，我们为我们的系统包装了一层RESTful 的API：</p><div class="highlight"><pre><code class="language-bash">http://hermes:8360/TaskInterface/CreateTask.php?
<span class="nv">task_type</span><span class="o">=</span>1234<span class="p">&amp;</span>           <span class="c"># 插件ID</span>
<span class="nv">task_name</span><span class="o">=</span><span class="nv">$task_name</span><span class="p">&amp;</span>     <span class="c"># 任务名，非必须</span>
<span class="nv">work_account</span><span class="o">=</span><span class="nv">$work_account</span><span class="p">&amp;</span> <span class="c"># 任务执行的用户</span>
<span class="nv">concurrency</span><span class="o">=</span><span class="nv">$concurrency</span><span class="p">&amp;</span> <span class="c"># 任务执行的并发度</span>
<span class="nv">plugin_info</span><span class="o">=</span><span class="nv">$plugin_info</span><span class="p">&amp;</span> <span class="c"># 给插件传递的参数</span>
<span class="nv">time_out</span><span class="o">=</span><span class="nv">$time_out</span><span class="p">&amp;</span>       <span class="c"># 任务执行超时时间</span>
<span class="nv">hostlist</span><span class="o">=</span><span class="nv">$hostlist</span><span class="p">&amp;</span>       <span class="c"># 任务执行的机器列表</span>
<span class="nv">callback</span><span class="o">=</span>urlencode<span class="o">(</span><span class="nv">$callback</span><span class="o">)</span> <span class="c"># 任务执行的回调</span>
</code></pre></div><p>通过这种方式，我们就允许用户用任何的语言进行开发。</p><br>著作权归作者所有，转载请联系作者获得授权。<br>作者：auxten<br>链接：<a href="http://zhuanlan.zhihu.com/auxten/20378870" class="internal"><span class="invisible">http://</span><span class="visible">zhuanlan.zhihu.com/auxt</span><span class="invisible">en/20378870</span><span class="ellipsis"></span></a><br>来源：知乎<br><br><img src="https://pic3.zhimg.com/91730ff8713adb3fb80d79dba4beb3de_b.jpg" data-rawwidth="344" data-rawheight="344" class="content_image" width="344"><p>服务端开发群：365534424，本文仅授权51
Reboot相关账号发布。</p></div><div class="entry-content"><h1 style="font-size:25px">10min手写（一）：服务器内存监控系统</h1><hr>2015-12-02T16:42:19+08:00<blockquote><p>本文作者<a href="https://github.com/shengxinjing" class=" wrap external" target="_blank" rel="nofollow noreferrer">shengxinjing (woniuppp) · GitHub<i class="icon-external"></i></a> ，授权发布</p><p>本文需要有一定的
Python和前端基础，如果没基础的，请关注我后续的基础教程系列博客</p></blockquote><p><a href="https://github.com/shengxinjing/my_blog/tree/master/monitor" class=" wrap external" target="_blank" rel="nofollow noreferrer">项目地址<i class="icon-external"></i></a>，可以看到具体的代码，喜欢请加个星星</p><h2>视频链接</h2><p>录制中间网出问题了，重启了一下，所以有两部分</p><ul><li><a href="http://v.qq.com/boke/gplay/6362f9ed32ee1bc6bcfe344f11a106c5_lyf0000015cvpaj_d0174xh1ft1.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">视频1<i class="icon-external"></i></a></li><li><a href="http://v.qq.com/boke/gplay/6362f9ed32ee1bc6bcfe344f11a106c5_lyf0000015cvpaj.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">视频2<i class="icon-external"></i></a></li></ul><p>本文的目的在于，尽可能用简单的代码，让大家了解内存监控的原理<br>主题思路</p><ul><li>获取内存信息</li><li>存储信息</li><li>展现</li><li>扩展<ul><li>加主机名,moitor部署在多台机器，不直接插数据库</li><li>通过http请求的方式，一台机器起flask专门存数据monitor</li></ul></li></ul><p>思路图<br></p><img src="https://pic3.zhimg.com/69d970fa8ac7a8a35e8aa0db05f24742_b.png" data-rawwidth="1200" data-rawheight="410" class="origin_image zh-lightbox-thumb" width="1200" data-original="https://pic3.zhimg.com/69d970fa8ac7a8a35e8aa0db05f24742_r.png"><br><h2>第一步，我们需要获取内存信息</h2><p>其实所有的监控项，包括内存数据，都是从文件中读取的，大家执行以下 cat /proc/meminfo就可以看到关于内存的信息，我们关注的是前四行，总内存，空闲内存，缓冲和缓存大小</p><p>计算内存占用量公式：</p><blockquote><p>(总内存-空闲内存-缓冲-缓存)/1024Mb</p></blockquote><p>代码呼之欲出 monitor.py</p><blockquote><p>用with打开文件，可以自动关闭，比直接open优雅那么一丢丢</p></blockquote><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">getMem</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'/proc/meminfo'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">free</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">buffers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mem_use</span> <span class="o">=</span> <span class="n">total</span><span class="o">-</span><span class="n">free</span><span class="o">-</span><span class="n">buffers</span><span class="o">-</span><span class="n">cache</span>
    <span class="k">print</span> <span class="n">mem_use</span><span class="o">/</span><span class="mi">1024</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">getMem</span><span class="p">()</span>
</code></pre></div><p>执行文件 python monitor.py，每一秒打印一条内存信息</p><div class="highlight"><pre><code class="language-text">[woniu@teach memory]$ python mointor.py 
2920
2919
2919
2919
2919
</code></pre></div><p>我们可以写个很搓的测试代码，占用一点内存，看看数据会不会变<br>执行下面代码，能看到内存使用量明显多了几M</p><br><div class="highlight"><pre><code class="language-text"># test.py

s = 'akdsakjhdjkashdjkhasjkdhasjkdhkjashdaskjhfoopnnm,ioqouiew'*100000

for i in s:
    for j in s:
        s.count(j)
~                     
</code></pre></div><p>获取内存数据done!</p><h2>第二部存储数据库</h2><p>###我们选用mysql</p><p>新建表格,我们需要两个字段，内存和时间 sql呼之欲出，简单粗暴</p><br><div class="highlight"><pre><code class="language-text">create memory(memory int,time int)
</code></pre></div><p>我们的 monitor.py就不能只打印内存信息了，要存储数据库啦,引入mysql模块，代码如下</p><br><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">MySQLdb</span> <span class="kn">as</span> <span class="nn">mysql</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">mysql</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="s">"reboot"</span><span class="p">,</span><span class="n">passwd</span><span class="o">=</span><span class="s">"reboot123"</span><span class="p">,</span><span class="n">db</span><span class="o">=</span><span class="s">"memory"</span><span class="p">,</span><span class="n">host</span><span class="o">=</span><span class="s">"localhost"</span><span class="p">)</span>
<span class="n">db</span><span class="o">.</span><span class="n">autocommit</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">getMem</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'/proc/meminfo'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">free</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">buffers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">mem_use</span> <span class="o">=</span> <span class="n">total</span><span class="o">-</span><span class="n">free</span><span class="o">-</span><span class="n">buffers</span><span class="o">-</span><span class="n">cache</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
    <span class="n">sql</span> <span class="o">=</span> <span class="s">'insert into memory (memory,time) value (</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)'</span><span class="o">%</span><span class="p">(</span><span class="n">mem_use</span><span class="o">/</span><span class="mi">1024</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">mem_use</span><span class="o">/</span><span class="mi">1024</span>
    <span class="c">#print 'ok'</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">getMem</span><span class="p">()</span>
</code></pre></div><p>比之前的多了拼接sql和执行的步骤，具体过程见视频，大家到数据库里执行一下下面的sql，就能看到我们辛辛苦苦获取的内存数据啦</p><br><div class="highlight"><pre><code class="language-text">    select * from memory
</code></pre></div><p>我们的数据库里数据越来越多，怎么展示呢</p><p>我们需要flask<br>我们看下文件结构</p><div class="highlight"><pre><code class="language-bash">.
├── flask_web.py web后端代码
├── mointor.py 监控数据获取
├── static 静态文件，第三方图表库
│   ├── exporting.js
│   ├── highstock.js
│   └── jquery.js
├── templates
│   └── index.html 展示前端页面
└── test.py 占用内存的测试代码
</code></pre></div><p>flask_web就是我们的web服务代码，template下面的html，就是前端展示的文件，static下面是第三方库</p><p>flask_web的代码如下</p><ul><li>提供两个路由<ul><li>根目录渲染文件index.html</li><li>/data路由去数据库插数据，返回json，供画图使用</li></ul></li></ul><div class="highlight"><pre><code class="language-python"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span><span class="n">render_template</span><span class="p">,</span><span class="n">request</span>
<span class="kn">import</span> <span class="nn">MySQLdb</span> <span class="kn">as</span> <span class="nn">mysql</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">mysql</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="s">'reboot'</span><span class="p">,</span><span class="n">passwd</span><span class="o">=</span><span class="s">'reboot123'</span><span class="p">,</span><span class="n">host</span><span class="o">=</span><span class="s">'localhost'</span><span class="p">,</span><span class="n">db</span><span class="o">=</span><span class="s">'memory'</span><span class="p">)</span>

<span class="n">con</span><span class="o">.</span><span class="n">autocommit</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">'index.html'</span><span class="p">)</span>


<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/data'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">data</span><span class="p">():</span>
    <span class="n">sql</span> <span class="o">=</span> <span class="s">'select * from memory'</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">():</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span><span class="p">,</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'0.0.0.0'</span><span class="p">,</span><span class="n">port</span><span class="o">=</span><span class="mi">9092</span><span class="p">,</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div><p>前端index.html<br><a href="http://code.hcharts.cn/highstock/hhhhio" class=" wrap external" target="_blank" rel="nofollow noreferrer">highstock的demo页面<i class="icon-external"></i></a>,copy过来，具体过程见视频</p><br><div class="highlight"><pre><code class="language-html"><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
<span class="nt">&lt;title&gt;</span>51reboot<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>

<span class="nt">&lt;body&gt;</span>
hello world

<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"container"</span> <span class="na">style=</span><span class="s">"height: 400px; min-width: 310px"</span><span class="nt">&gt;&lt;/div&gt;</span>

<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">'/static/jquery.js'</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">'/static/highstock.js'</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">'/static/exporting.js'</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="nx">$</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 使用当前时区，否则东八区会差八个小时</span>
    <span class="nx">Highcharts</span><span class="p">.</span><span class="nx">setOptions</span><span class="p">({</span>
        <span class="nx">global</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">useUTC</span><span class="o">:</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="s1">'/data'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// Create the chart</span>
        <span class="nx">$</span><span class="p">(</span><span class="s1">'#container'</span><span class="p">).</span><span class="nx">highcharts</span><span class="p">(</span><span class="s1">'StockChart'</span><span class="p">,</span> <span class="p">{</span>

            <span class="nx">rangeSelector</span> <span class="o">:</span> <span class="p">{</span>
                <span class="nx">selected</span> <span class="o">:</span> <span class="mi">1</span>
            <span class="p">},</span>

            <span class="nx">title</span> <span class="o">:</span> <span class="p">{</span>
                <span class="nx">text</span> <span class="o">:</span> <span class="s1">'内存数据'</span>
            <span class="p">},</span>

            <span class="nx">series</span> <span class="o">:</span> <span class="p">[{</span>
                <span class="nx">name</span> <span class="o">:</span> <span class="s1">'本机内存'</span><span class="p">,</span>
                <span class="nx">data</span> <span class="o">:</span> <span class="nx">data</span><span class="p">,</span>
                <span class="nx">tooltip</span><span class="o">:</span> <span class="p">{</span>
                    <span class="nx">valueDecimals</span><span class="o">:</span> <span class="mi">2</span>
                <span class="p">}</span>
            <span class="p">}]</span>
        <span class="p">});</span>
    <span class="p">});</span>

<span class="p">});</span>
<span class="nt">&lt;/script&gt;</span>

<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div><p>具体观察数据结构的过程，见视频和<a href="http://code.hcharts.cn/highstock/hhhhio" class=" wrap external" target="_blank" rel="nofollow noreferrer">demo链接<i class="icon-external"></i></a>，我们做的 就是把数据库里的数据，拼接成前端画图需要的数据，展现出来</p><p>这时候前端就能看到图表啦</p><img src="https://pic1.zhimg.com/d9b0d2b176b907e8a6e55dd7e824b4f4_b.jpg" data-rawwidth="1279" data-rawheight="417" class="origin_image zh-lightbox-thumb" width="1279" data-original="https://pic1.zhimg.com/d9b0d2b176b907e8a6e55dd7e824b4f4_r.jpg"><p>我们并不仅限于此，如果想实时的看到内存，应该怎么搞呢</p><ul><li>查询数据时候增加一个时间戳当限制条件，再次查询时，只返回两次查询之间的增量数据</li><li>前端动态添加增量结点数据到图表中</li><li>代码呼之欲出</li></ul><p>python</p><div class="highlight"><pre><code class="language-python"><span class="n">tmp_time</span> <span class="o">=</span> <span class="mi">0</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/data'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">data</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">tmp_time</span>
    <span class="k">if</span> <span class="n">tmp_time</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">sql</span> <span class="o">=</span> <span class="s">'select * from memory where time&gt;</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">tmp_time</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sql</span> <span class="o">=</span> <span class="s">'select * from memory'</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">():</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span><span class="p">,</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">tmp_time</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</code></pre></div><p>前端,3秒查一次增量数据</p><div class="highlight"><pre><code class="language-js">    <span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="s1">'/data'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// Create the chart</span>
        <span class="nx">$</span><span class="p">(</span><span class="s1">'#container'</span><span class="p">).</span><span class="nx">highcharts</span><span class="p">(</span><span class="s1">'StockChart'</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">chart</span><span class="o">:</span><span class="p">{</span>
        <span class="nx">events</span><span class="o">:</span><span class="p">{</span>
            <span class="nx">load</span><span class="o">:</span><span class="kd">function</span><span class="p">(){</span>
                <span class="kd">var</span> <span class="nx">series</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
                <span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="s1">'/data'</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span>
                    <span class="nx">$</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">v</span><span class="p">){</span>
                        <span class="nx">series</span><span class="p">.</span><span class="nx">addPoint</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
                    <span class="p">})</span>
                <span class="p">})</span>
                <span class="p">},</span><span class="mi">3000</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="p">},</span>

            <span class="nx">rangeSelector</span> <span class="o">:</span> <span class="p">{</span>
                <span class="nx">selected</span> <span class="o">:</span> <span class="mi">1</span>
            <span class="p">},</span>

            <span class="nx">title</span> <span class="o">:</span> <span class="p">{</span>
                <span class="nx">text</span> <span class="o">:</span> <span class="s1">'AAPL Stock Price'</span>
            <span class="p">},</span>

            <span class="nx">series</span> <span class="o">:</span> <span class="p">[{</span>
                <span class="nx">name</span> <span class="o">:</span> <span class="s1">'AAPL'</span><span class="p">,</span>
                <span class="nx">data</span> <span class="o">:</span> <span class="nx">data</span><span class="p">,</span>
                <span class="nx">tooltip</span><span class="o">:</span> <span class="p">{</span>
                    <span class="nx">valueDecimals</span><span class="o">:</span> <span class="mi">2</span>
                <span class="p">}</span>
            <span class="p">}]</span>
        <span class="p">});</span>
    <span class="p">});</span>
</code></pre></div><p>done！两个文件都搞定，double kill！<br>效果</p><p>最终代码<a href="https://github.com/shengxinjing/python_blog/tree/master/monitor" class=" wrap external" target="_blank" rel="nofollow noreferrer">直接下载那个木看也行<i class="icon-external"></i></a></p><p>监控文件monitor.py</p><br><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">MySQLdb</span> <span class="kn">as</span> <span class="nn">mysql</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">mysql</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="s">"reboot"</span><span class="p">,</span><span class="n">passwd</span><span class="o">=</span><span class="s">"reboot123"</span><span class="p">,</span><span class="n">db</span><span class="o">=</span><span class="s">"memory"</span><span class="p">,</span><span class="n">host</span><span class="o">=</span><span class="s">"localhost"</span><span class="p">)</span>
<span class="n">db</span><span class="o">.</span><span class="n">autocommit</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">getMem</span><span class="p">():</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'/proc/meminfo'</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">free</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">buffers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mem_use</span> <span class="o">=</span> <span class="n">total</span><span class="o">-</span><span class="n">free</span><span class="o">-</span><span class="n">buffers</span><span class="o">-</span><span class="n">cache</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
    <span class="n">sql</span> <span class="o">=</span> <span class="s">'insert into memory (memory,time) value (</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)'</span><span class="o">%</span><span class="p">(</span><span class="n">mem_use</span><span class="o">/</span><span class="mi">1024</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">mem_use</span><span class="o">/</span><span class="mi">1024</span>
    <span class="c">#print 'ok'</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">getMem</span><span class="p">()</span>
</code></pre></div><p>flask</p><br><div class="highlight"><pre><code class="language-python"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span><span class="n">render_template</span><span class="p">,</span><span class="n">request</span>
<span class="kn">import</span> <span class="nn">MySQLdb</span> <span class="kn">as</span> <span class="nn">mysql</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">mysql</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="s">'reboot'</span><span class="p">,</span><span class="n">passwd</span><span class="o">=</span><span class="s">'reboot123'</span><span class="p">,</span><span class="n">host</span><span class="o">=</span><span class="s">'localhost'</span><span class="p">,</span><span class="n">db</span><span class="o">=</span><span class="s">'memory'</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">autocommit</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">'index.html'</span><span class="p">)</span>

<span class="n">tmp_time</span> <span class="o">=</span> <span class="mi">0</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/data'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">data</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">tmp_time</span>
    <span class="k">if</span> <span class="n">tmp_time</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">sql</span> <span class="o">=</span> <span class="s">'select * from memory where time&gt;</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">tmp_time</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sql</span> <span class="o">=</span> <span class="s">'select * from memory'</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">():</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span><span class="p">,</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">tmp_time</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'0.0.0.0'</span><span class="p">,</span><span class="n">port</span><span class="o">=</span><span class="mi">9092</span><span class="p">,</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div><p>前端</p><br><div class="highlight"><pre><code class="language-html"><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
<span class="nt">&lt;title&gt;</span>51reboot<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">'utf-8'</span><span class="nt">&gt;</span>
<span class="nt">&lt;/head&gt;</span>

<span class="nt">&lt;body&gt;</span>
hello world

<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"container"</span> <span class="na">style=</span><span class="s">"height: 400px; min-width: 310px"</span><span class="nt">&gt;&lt;/div&gt;</span>

<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">'/static/jquery.js'</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">'/static/highstock.js'</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">'/static/exporting.js'</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="nx">$</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 使用当前时区，否则东八区会差八个小时</span>
    <span class="nx">Highcharts</span><span class="p">.</span><span class="nx">setOptions</span><span class="p">({</span>
        <span class="nx">global</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">useUTC</span><span class="o">:</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="s1">'/data'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// Create the chart</span>
        <span class="nx">$</span><span class="p">(</span><span class="s1">'#container'</span><span class="p">).</span><span class="nx">highcharts</span><span class="p">(</span><span class="s1">'StockChart'</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">chart</span><span class="o">:</span><span class="p">{</span>
        <span class="nx">events</span><span class="o">:</span><span class="p">{</span>

            <span class="nx">load</span><span class="o">:</span><span class="kd">function</span><span class="p">(){</span>

                <span class="kd">var</span> <span class="nx">series</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
                <span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="s1">'/data'</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span>
                    <span class="nx">$</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">v</span><span class="p">){</span>
                        <span class="nx">series</span><span class="p">.</span><span class="nx">addPoint</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
                    <span class="p">})</span>
                <span class="p">})</span>
                <span class="p">},</span><span class="mi">3000</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="p">},</span>

            <span class="nx">rangeSelector</span> <span class="o">:</span> <span class="p">{</span>
                <span class="nx">selected</span> <span class="o">:</span> <span class="mi">1</span>
            <span class="p">},</span>

            <span class="nx">title</span> <span class="o">:</span> <span class="p">{</span>
                <span class="nx">text</span> <span class="o">:</span> <span class="s1">'内存数据'</span>
            <span class="p">},</span>

            <span class="nx">series</span> <span class="o">:</span> <span class="p">[{</span>
                <span class="nx">name</span> <span class="o">:</span> <span class="s1">'本机内存'</span><span class="p">,</span>
                <span class="nx">data</span> <span class="o">:</span> <span class="nx">data</span><span class="p">,</span>
                <span class="nx">tooltip</span><span class="o">:</span> <span class="p">{</span>
                    <span class="nx">valueDecimals</span><span class="o">:</span> <span class="mi">2</span>
                <span class="p">}</span>
            <span class="p">}]</span>
        <span class="p">});</span>
    <span class="p">});</span>

<span class="p">});</span>
<span class="nt">&lt;/script&gt;</span>

<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div><p>代码没有特别注意细节，希望大家喜欢</p><p>运维开发交流QQ群：238757010</p><br><p>欢迎大家关注公共号，高品质运维开发</p><img src="https://pic3.zhimg.com/7008c662deb255e4403640e068f6fd02_b.jpg" data-rawwidth="430" data-rawheight="430" class="origin_image zh-lightbox-thumb" width="430" data-original="https://pic3.zhimg.com/7008c662deb255e4403640e068f6fd02_r.jpg"><p>本文仅授权51Reboot相关账号发布。</p></div><div class="entry-content"><h1 style="font-size:25px">10min手写（二）：日志展示系统</h1><hr>2015-12-06T21:10:09+08:00<p>本文原载于：<a href="https://github.com/shengxinjing/my_blog/issues/2" class=" wrap external" target="_blank" rel="nofollow noreferrer">日志可视化的进阶 · Issue #2 · shengxinjing/my_blog · GitHub<i class="icon-external"></i></a><br></p><blockquote><p>本文需要有一定的
Python和前端基础，如果没基础的，请关注我后续的基础教程系列博客<br>本文所有的demo，都是浏览器下展示的</p><p><u><b>基情授权，非授权拒绝任何形式的转载</b></u></p></blockquote><p><a href="https://github.com/shengxinjing/my_blog/tree/master/log_visual" class=" wrap external" target="_blank" rel="nofollow noreferrer">项目地址<i class="icon-external"></i></a>，蜗牛跪求右Github上角star <br><br>基于
Python，前端基于echarts,力求用简单的代码说明原理</p><h2>提纲</h2><ul><li>access日志按照什么维度展示数据</li><li>和web结合，更好的体验，只需记住URL</li><li>分页排序和搜索，表格展示体验的提升</li><li>一图胜万言，汇总信息更友好的展示</li><li>逼格满满，让IP信息在地图上展示</li><li>后续展望--机房网络流量可视化，机器、机柜、机房3D展示</li></ul><h2>背景</h2><h3>老板要看日志数据汇总</h3><ul><li>本文重点：如何做可视化</li><li>目标：如何用友好的方式去展现沉闷繁冗的数据</li><li>下个月就发年终奖！！！</li><li>为了说明可视化的方式，用一个简单的log举例子</li></ul><h2>原材料</h2><ul><li>一个标准的access_log日志 大概2W行</li><li>老板想要这个日志的分析结果，每个url,ip,status分别访问多少次，把前几名统计出来看看</li><li>分析出统计数据 展现结果</li></ul><h2>很普通的日志，大概长这样</h2><h3>为了方便展示，切割了一下，大概2W行</h3><div class="highlight"><pre><code class="language-irc">61.159.140.123 - - [23/Aug/2014:00:01:42 +0800] "GET /favicon.ico HTTP/1.1" 404 \ "-" "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36 LBBROWSER" "-"
61.159.140.123 - - [23/Aug/2014:00:01:42 +0800] "GET /favicon.ico HTTP/1.1" 404 \ "-" "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36 LBBROWSER" "-"
61.159.140.123 - - [23/Aug/2014:00:01:42 +0800] "GET /favicon.ico HTTP/1.1" 404 \ "-" "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36 LBBROWSER" "-"
61.159.140.123 - - [23/Aug/2014:00:01:42 +0800] "GET /favicon.ico HTTP/1.1" 404 \ "-" "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36 LBBROWSER" "-"
66.249.64.5 - - [23/Aug/2014:00:02:16 +0800] "GET /data/uploads/2013/0519/09/small_51982ba18e012.jpg HTTP/1.1" 200 \ "-" "Googlebot-Image/1.0" "-"
66.249.64.10 - - [23/Aug/2014:00:02:54 +0800] "GET /data/uploads/2013/0319/08/middle_5147b116e93b4.jpg HTTP/1.1" 200 \ "-" "Googlebot-Image/1.0" "-"
</code></pre></div><h2>目标</h2><ul><li>初级展现</li><li>友好交互</li><li>饼图汇总</li><li>更进一步</li><li>后续展望</li></ul><h2>级别1</h2><ul><li>数据处理，命令行展现</li><li>打开文件，处理完数据后排序</li><li>打印前10</li></ul><h2>talk is cheap, show me the code!</h2><div class="highlight"><pre><code class="language-python"><span class="c"># coding=utf-8</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'www_access_20140823.log'</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="c"># 获取ip url 和status</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="c"># ip url 和status当key，每次统计+1</span>
    <span class="n">res</span><span class="p">[(</span><span class="n">ip</span><span class="p">,</span><span class="n">url</span><span class="p">,</span><span class="n">status</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span><span class="n">url</span><span class="p">,</span><span class="n">status</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="c"># 生成一个临时的list</span>
<span class="n">res_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
<span class="c"># 按照统计数量排序，打印前10</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">res_list</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="mi">10</span><span class="p">]:</span>
    <span class="k">print</span> <span class="n">k</span>
</code></pre></div><h2>处理结果</h2><div class="highlight"><pre><code class="language-pytb"><span class="x">('222.86.153.12', '/images/cursor_minify.cur', '404', 60)</span>
<span class="x">('222.86.153.12', '/images/cursor_zoom.cur', '404', 32)</span>
<span class="x">('58.253.6.133', '/images/cursor_minify.cur', '404', 32)</span>
<span class="x">('111.85.34.165', '/%3Ca%20href=', '404', 28)</span>
<span class="x">('58.253.6.133', '/images/cursor_zoom.cur', '404', 27)</span>
<span class="x">('218.29.111.117', '/images/cursor_zoom.cur', '404', 27)</span>
<span class="x">('218.29.111.117', '/images/cursor_minify.cur', '404', 26)</span>
<span class="x">('117.63.146.40', '/public/js/common.js?20110824', '200', 19)</span>
<span class="x">('117.63.146.40', '/favicon.ico', '404', 18)</span>
<span class="x">('117.63.146.40', '/public/js/weibo.js?20110824', '200', 16)</span>
</code></pre></div><h2>任务完成</h2><ul><li>下一步粘到邮件里，或者生成一个csv文件发出去</li><li>然而这是一个看脸的社会,运维也逃脱不了这个魔咒</li></ul><h2>级别2</h2><h3>浏览器端展现</h3><p>生成list之后，拼接SQL，存入数据库</p><h2>talk is cheap, show me the code!</h2><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">MySQLdb</span> <span class="kn">as</span> <span class="nn">mysql</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">mysql</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="s">'root'</span><span class="p">,</span>\
                    <span class="n">passwd</span><span class="o">=</span><span class="s">''</span><span class="p">,</span>\
                    <span class="n">db</span><span class="o">=</span><span class="s">'log'</span><span class="p">,</span>\
                    <span class="n">host</span><span class="o">=</span><span class="s">'localhost'</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">autocommit</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="c"># 处理文件省略</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">res_list</span><span class="p">:</span>
    <span class="n">sql</span> <span class="o">=</span> <span class="s">'insert log values ("</span><span class="si">%s</span><span class="s">","</span><span class="si">%s</span><span class="s">",</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)'</span> <span class="o">%</span> <span class="n">s</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c"># 入库</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">pass</span>
</code></pre></div><h2>前端展现</h2><h3>读库 展现页面</h3><h3>talk is cheap, show me the money!</h3><div class="highlight"><pre><code class="language-python"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span><span class="n">request</span><span class="p">,</span><span class="n">render_template</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">MySQLdb</span> <span class="kn">as</span> <span class="nn">mysql</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">mysql</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="s">'xx'</span><span class="p">,</span>\
                    <span class="n">passwd</span><span class="o">=</span><span class="s">'xx'</span><span class="p">,</span>\
                    <span class="n">db</span><span class="o">=</span><span class="s">'xx'</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">table</span> <span class="o">=</span> <span class="s">'&lt;table border="1"&gt;'</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">'select * from log order by value desc limit 20; '</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">():</span>
        <span class="n">table</span> <span class="o">+=</span> <span class="s">'&lt;tr&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s">&lt;/td&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s">&lt;/td&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s">&lt;/td&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s">&lt;/td&gt;&lt;/tr&gt;'</span><span class="o">%</span><span class="n">c</span>
    <span class="n">table</span> <span class="o">+=</span><span class="s">'&lt;/table&gt;'</span>
    <span class="k">return</span> <span class="n">table</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'0.0.0.0'</span><span class="p">,</span><span class="n">port</span><span class="o">=</span><span class="mi">9092</span><span class="p">)</span>
</code></pre></div><h2>给老板一个url即可，老板想看随时能看</h2><img src="https://pic1.zhimg.com/e330204f608f9b69fbaba0ace4b9481c_b.jpg" data-rawwidth="635" data-rawheight="478" class="origin_image zh-lightbox-thumb" width="635" data-original="https://pic1.zhimg.com/e330204f608f9b69fbaba0ace4b9481c_r.jpg"><br><h2>但是老板表示有点丑</h2><img src="https://pic4.zhimg.com/65f6fc8c7ace221b8fdf3199f7df7cd7_b.png" data-rawwidth="264" data-rawheight="257" class="content_image" width="264"><br><h2>完整的思路</h2><img src="https://pic2.zhimg.com/c7ec4f82d4e5c216339580d76aefdd01_b.png" data-rawwidth="1023" data-rawheight="410" class="origin_image zh-lightbox-thumb" width="1023" data-original="https://pic2.zhimg.com/c7ec4f82d4e5c216339580d76aefdd01_r.png"><br><h3>前端展现上做一些优化</h3><ul><li>分页</li><li>表格排序</li><li>搜索</li><li>控制每页显示数量</li><li>数据多了之后，前端交互和后端数据的接口配合</li></ul><br><p>我们的console页面，提供几个汇总信息，那就更好啦，比如根据http的status来个汇总，难不倒我，一句SQL搞定</p><br><div class="highlight"><pre><code class="language-mysql"><span class="k">select</span> <span class="n">status</span><span class="p">,</span><span class="nf">sum</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">from</span> <span class="n">log</span> <span class="k">group</span> <span class="k">by</span> <span class="n">status</span>
<span class="o">+--------+------------+</span>
<span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="nf">sum</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+--------+------------+</span>
<span class="o">|</span>    <span class="mi">200</span> <span class="o">|</span>      <span class="mi">15529</span> <span class="o">|</span>
<span class="o">|</span>    <span class="mi">206</span> <span class="o">|</span>          <span class="mi">6</span> <span class="o">|</span>
<span class="o">|</span>    <span class="mi">301</span> <span class="o">|</span>          <span class="mi">2</span> <span class="o">|</span>
<span class="o">|</span>    <span class="mi">304</span> <span class="o">|</span>       <span class="mi">3549</span> <span class="o">|</span>
<span class="o">|</span>    <span class="mi">403</span> <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>
<span class="o">|</span>    <span class="mi">404</span> <span class="o">|</span>        <span class="mi">847</span> <span class="o">|</span>
<span class="o">+--------+------------+</span>
<span class="mi">6</span> <span class="n">rows</span> <span class="k">in</span> <span class="kt">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">02</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div><h2>汇总信息可视化</h2><h3>根据https状态汇总</h3><img src="https://pic4.zhimg.com/9432479ecbe6b8d1b621cf10c54240fb_b.png" data-rawwidth="500" data-rawheight="400" class="origin_image zh-lightbox-thumb" width="500" data-original="https://pic4.zhimg.com/9432479ecbe6b8d1b621cf10c54240fb_r.png"><br><h2>其他功能</h2><ul><li>图例开关</li><li>图表转换</li><li>数据视图</li><li>直接导出图片</li></ul><p>可视化并不仅限于此，上面只是举得小栗子</p><br><p>如果你对时间更感兴趣，我们的log里也是有时间信息的,可以像下面这样</p><p>统计量，时间轴拖动，保存图片，etc</p><p>如何让日志数据更加一目了然，让老板觉得你很有逼格呢</p><p>更进一步</p><br><img src="https://pic3.zhimg.com/486fbc4c5336c1b5e241fbea2b3a0746_b.png" data-rawwidth="303" data-rawheight="315" class="content_image" width="303"><br><h3>IP都是有地址位置的，定位每个ip的位置，画个地图出来汇总</h3><img src="https://pic2.zhimg.com/05cf90229c13e4e6d5472924ec6a7f31_b.png" data-rawwidth="323" data-rawheight="275" class="content_image" width="323"><br><h3>经纬度坐标系统</h3><ul><li>地球坐标(WGS84)<ul><li>国际标准，从 GPS 设备中取出的数据的坐标系</li><li>国际地图提供商使用的坐标系</li></ul></li><li>火星坐标(GCJ-02)<ul><li>中国标准，从国行移动设备中定位获取的坐标数据使用这个坐标系</li></ul></li><li>百度坐标(BD-09)<ul><li>百度标准，百度 SDK，百度地图，Geocoding 使用</li></ul></li></ul><h3>应用场景</h3><ul><li>WGS84坐标系：<ul><li>国际标准，谷歌国外地图、osm地图等国外的地图一般都是这个</li></ul></li><li>火星坐标系：<ul><li>iOS 地图</li><li>Gogole地图</li><li>搜搜、阿里云、高德地图</li></ul></li><li>百度坐标系：<ul><li>当然只有百度地图</li></ul></li></ul><h2>地图是需要经纬度的，用第三方的ip库转换一下</h2><h3><a href="http://developer.baidu.com/map/index.php?title=webapi/ip-api" class=" wrap external" target="_blank" rel="nofollow noreferrer">webapi/ip-api<i class="icon-external"></i></a></h3><img src="https://pic3.zhimg.com/8485c51c81cdc8085ed8098ac2a3efc2_b.png" data-rawwidth="1201" data-rawheight="462" class="origin_image zh-lightbox-thumb" width="1201" data-original="https://pic3.zhimg.com/8485c51c81cdc8085ed8098ac2a3efc2_r.png"><br><h2>talk is cheap, show me the code!</h2><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">urllib2</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="n">key</span> <span class="o">=</span> <span class="s">'q5mTrTGzCSVq5QmGpI9y18Bo'</span>
<span class="n">ipurl</span> <span class="o">=</span> <span class="s">'http://api.map.baidu.com/location/ip?ak='</span><span class="o">+</span><span class="n">key</span><span class="o">+</span><span class="s">'&amp;coor=bd09ll&amp;ip='</span>
<span class="n">sqlarr</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">getGeo</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">ipurl</span><span class="o">+</span><span class="n">ip</span><span class="p">)</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">'content'</span> <span class="ow">in</span> <span class="n">page</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">page</span><span class="p">[</span><span class="s">'content'</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'point'</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">'ip </span><span class="si">%s</span><span class="s"> has geoX </span><span class="si">%s</span><span class="s"> and geoY </span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="n">point</span><span class="p">[</span><span class="s">'x'</span><span class="p">],</span><span class="n">point</span><span class="p">[</span><span class="s">'y'</span><span class="p">])</span> 
    <span class="k">except</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'error'</span>
<span class="n">getGeo</span><span class="p">(</span><span class="s">'202.198.16.3'</span><span class="p">)</span>
<span class="c"># ip 202.198.16.3 has geoX 125.31364243 and geoY 43.89833761</span>
</code></pre></div><h2>就想玩网游时候，坐标可以定位一个人，经纬度可以再地图上定位一个点，画图展现</h2><img src="https://pic1.zhimg.com/1468d4ba29d16625a9b11be18f77d58c_b.png" data-rawwidth="638" data-rawheight="454" class="origin_image zh-lightbox-thumb" width="638" data-original="https://pic1.zhimg.com/1468d4ba29d16625a9b11be18f77d58c_r.png"><h2>刚才那个图仅关注区域，进阶一下，还要关注访问量</h2><h3>可以根据value筛选</h3><img src="https://pic4.zhimg.com/2b7dfb777740ec28a46099ca35f6d7ff_b.png" data-rawwidth="902" data-rawheight="454" class="origin_image zh-lightbox-thumb" width="902" data-original="https://pic4.zhimg.com/2b7dfb777740ec28a46099ca35f6d7ff_r.png"><br><h2>进阶:多台机器的日志</h2><ul><li>获取每个机器的hostname和ip，和日志数据一起存在数据库里</li><li>一个表存日志，带上一个机器的id</li><li>机器的id=&gt;ip和经纬度</li><li>最终统计访问量</li></ul><img src="https://pic4.zhimg.com/f9bc3634820e8abb7afcb81d744a35e7_b.jpg" data-rawwidth="902" data-rawheight="454" class="origin_image zh-lightbox-thumb" width="902" data-original="https://pic4.zhimg.com/f9bc3634820e8abb7afcb81d744a35e7_r.jpg"><br><h2>后续扩展</h2><ul><li>日志数据</li><li>前端展现场景</li></ul><h3>怎么实践</h3><ul><li>这次分享的主题关注与可视化</li><li>我们用了一个很小的静态日志，目的是说明可视化的思路</li><li>实际工作中日志数据应该怎么处理</li></ul><h2>ELK == Logstash + ElasticSearch + Kibana4</h2><img src="https://pic2.zhimg.com/1ce3ef88f8b367b2ea39d6e3f746fdb1_b.png" data-rawwidth="1600" data-rawheight="936" class="origin_image zh-lightbox-thumb" width="1600" data-original="https://pic2.zhimg.com/1ce3ef88f8b367b2ea39d6e3f746fdb1_r.png"><br><ul><li>
Logstash<ul><li>日志进行收集、分析，并将其存储供使用</li></ul></li><li>ElasticSearch<ul><li>开源分布式搜索引擎，</li></ul></li><li>Kibana4<ul><li>日志分析友好的 Web 界面</li></ul></li><li>其他<ul><li>Kafka scribe等</li></ul></li></ul><h3>常见日志处理架构</h3><ul><li>ELK</li><li>logstash+Hadoop</li><li>scribe+hadoop</li><li>线上数据-&gt;Flume-&gt;Kafka-&gt;Hdfs-&gt;Map/Reduce</li><li>线上数据-&gt;flume-&gt;kafka-&gt;storm</li><li>在上面的基础上定制化二次开发，比如MR平台上写代码，我们的代码就可以直接拿来用</li><li>日志的数据处理架构详情，请见下回分解</li></ul><br><p>知乎不资瓷GIF，移步这里：<a href="https://github.com/shengxinjing/my_blog/issues/2" class=" wrap external" target="_blank" rel="nofollow noreferrer">日志可视化的进阶 · Issue #2 · shengxinjing/my_blog · GitHub<i class="icon-external"></i></a></p><p><u>基情授权，非授权拒绝任何形式的转载。<img src="https://pic3.zhimg.com/7008c662deb255e4403640e068f6fd02_b.jpg" data-rawwidth="430" data-rawheight="430" class="origin_image zh-lightbox-thumb" width="430" data-original="https://pic3.zhimg.com/7008c662deb255e4403640e068f6fd02_r.jpg"></u></p></div><div class="entry-content"><h1 style="font-size:25px">网络编程（六）：CAP原理推导和应用</h1><hr>2015-12-07T21:18:15+08:00<h3>在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：<br></h3><ul><li>一致性 (Consistency)（等同于所有节点访问同一份最新的数据副本）</li><li>可用性（Availability）（对数据更新具备高可用性）</li><li>网络分区容忍性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）</li></ul><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。</p><p>理解CAP理论的最简单方式是想象两个节点分处分区两侧。 允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。 如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。 除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</p><p>这个定理起源于加州大学伯克利分校（University of California, Berkeley）的计算机科学家埃里克·布鲁尔在2000年的分布式计算原则研讨会 （Symposium on Principles of Distributed Computing（PODC））上提出的一个猜想。 在2002年，麻省理工学院（MIT）的赛斯·吉尔伯特和南希·林奇发表了布鲁尔猜想的证明， 使之成为一个定理。 吉尔伯特和林奇证明的CAP定理比布鲁尔设想的某种程度上更加狭义。 定理讨论了在两个互相矛盾的请求到达彼此连接不通的两个不同的分布式节点的时候的处理方案。</p><p>From：<a href="http://wikipedia.org/" class=" wrap external" target="_blank" rel="nofollow noreferrer">WikiPedia.org<i class="icon-external"></i></a></p><p>当我第一次读完WikiPedia的解释是似懂非懂的，现在懂了觉得WikiPedia这个条目的撰写者真是字字珠玑。</p><h4>CAP原理实例推导</h4><p>我们以数据库为例，讨论一下CAP原理。</p><h4>单实例</h4><p>首先，我们讨论一种最简单的情况："单数据库实例"。 这也是最常见的小站点、个人博客、小论坛的架构。</p><img src="https://pic3.zhimg.com/ebc7d2819bde9f31a64c600e52f55e82_b.png" data-rawwidth="698" data-rawheight="646" class="origin_image zh-lightbox-thumb" width="698" data-original="https://pic3.zhimg.com/ebc7d2819bde9f31a64c600e52f55e82_r.png"><p>我们可以很容易分析出来，由于单实例，所以不存在“网络分区”、“不一致”， 但单点故障后会导致整个数据库瘫痪，所以可用性不能保证。</p><p>这就是CAP定理中的，保证"C"和"P"，舍弃"A"。</p><p>所有单机版的系统都属于这个范畴，例如MySQL、memcached、redis。</p><h4>Sharding</h4><p>Sharding可以翻译为分片。</p><p>为了提升可用性，我们在实际生产环境下经常会在客户端应用一些哈希算法，进行数据分片存放，如下图所示：</p><img src="https://pic4.zhimg.com/e4aa992e9783a0b0d64875fee506105f_b.png" data-rawwidth="778" data-rawheight="726" class="origin_image zh-lightbox-thumb" width="778" data-original="https://pic4.zhimg.com/e4aa992e9783a0b0d64875fee506105f_r.png"><p>由于数据是分片存储在每个数据库中，所以依旧能保证数据一致性。</p><p>由于数据库之间没有互相通信，并不依赖彼此的存在，所以分区可容忍性依旧没有破坏。</p><p>那么可用性呢？很多时候会有人直接拍脑袋，这里我们用数学的方式来解答这个问题。</p><p>假设，集群有两台服务器，数据分布均匀，我们数据库实例宕机的概率是p。 那么这种利用哈希进行数据分片的集群的可用性为：</p><img src="https://pic1.zhimg.com/b7979b2c044f3bb8f998629693059c2c_b.png" data-rawwidth="896" data-rawheight="116" class="origin_image zh-lightbox-thumb" width="896" data-original="https://pic1.zhimg.com/b7979b2c044f3bb8f998629693059c2c_r.png"><p>即使，数据分布均匀或者集群数量增大，结果也是一样的：“集群可用性依旧为p”。</p><p>那我们折腾了半天，CAP和单机竟然是一样的，为了个球啊？ 这种情况下CAP各项指标虽然没有提升，但好处是：</p><ol><li>单个服务器宕机只会导致服务降级；</li><li>集群有了扩容缩容的可能性，这就叫做scalability。</li></ol><p>这种分布式的方式常用于：</p><ul><li>分布式memcached、redis</li><li>传统的数据库Sharding</li><li>BigTable (列存储式数据库)</li><li>Hypertable (列存储式数据库)</li><li>HBase (列存储式数据库)</li><li>MongoDB (文档式数据库)</li><li>Terrastore (文档式数据库)</li><li>Redis (KV数据库)</li><li>Scalaris (KV数据库)</li><li>MemcacheDB (KV数据库)</li><li>Berkeley DB (KV数据库)</li></ul><h4>多副本写入</h4><p>如果我们想要保证更高的可用性，那应该怎么办呢？我们就有了下面的做法：</p><img src="https://pic4.zhimg.com/faa86dbe7cb3eb930b99bbabac7374ab_b.png" data-rawwidth="842" data-rawheight="856" class="origin_image zh-lightbox-thumb" width="842" data-original="https://pic4.zhimg.com/faa86dbe7cb3eb930b99bbabac7374ab_r.png"><p>Client多副本写入，就是Client在写数据库的时候对多个数据库进行写入，并且在两个都写入成功后才认为成功。 由于数据存在多个副本，这种方式会大大的提高读取的可用性。但由于写入的时候要多写， 副本所在的所有实例都必须可用才能成功。所以写入的可用性反而下降了。</p><p>假设单机数据库的故障率为p（p&lt;1.0），那么单机数据库的可用性为1-p。 总结就是：</p><ul><li>在写入的场景下，一致性( C )和分区可容忍性( P )没有变化，可用性( A )反而有所下降， 从1-p降低到1-2p-p²</li><li>在读取的场景下，一致性( C )和分区可容忍性( P )依旧没有变化，可用性( A )有所上升， 从1-p上升到1-p²</li></ul><p>我们可以进一步得到结论：</p><div class="highlight"><pre><code class="language-text">"Client多副本写入"这种写入方式非常适合于在"读多写少"的场景下提高可用性。
</code></pre></div><p>为了改善写入时糟糕的可用性，这种方式还有一些“变种”，例如：</p><ul><li>写成功部分副本就返回成功，剩下的副本写入不保证结果。这样做的结果就是牺牲一定的一致性( C )，换取可用性( A )的提升。</li></ul><p>总的来说，这种方式属于广义的"Sharding"的范畴，除去上述的缺点还有一个较大的问题就是：</p><p>假设副本数为n，Client写入单实例的耗时为t，多副本写入的耗时就是n*t；当n &gt; 1的时候会成倍的影响Client的写入性能。</p><h4>Clustering</h4><p>为了解决Client写入慢调用复杂等问题，我们引入了集群方案，也就是Clustering。 Clustering和Sharding对比如下：</p><img src="https://pic1.zhimg.com/1813ef3a81e938baec57b5fe47657734_b.png" data-rawwidth="930" data-rawheight="438" class="origin_image zh-lightbox-thumb" width="930" data-original="https://pic1.zhimg.com/1813ef3a81e938baec57b5fe47657734_r.png"><p><br>多副本模式：</p><img src="https://pic2.zhimg.com/b948f04dd22849b3f839e19a3e8af771_b.png" data-rawwidth="1076" data-rawheight="1162" class="origin_image zh-lightbox-thumb" width="1076" data-original="https://pic2.zhimg.com/b948f04dd22849b3f839e19a3e8af771_r.png"><p>我们可以看到，由于多个副本写入成功才返回，这种方式一致性( C )依旧是保证的。 但写入可用性( A )和分区可容忍性( P )相对于单机均会下降。换来的是：</p><ol><li>较为简单的API，客户端不用关注“多写”问题；</li><li>读取操作的高可用(HA)。</li></ol><p>由于上述方案是强一致性( C )的，这种应用场景常见于金融系统，这种这方面典型的代表有：</p><ul><li>ZooKeeper (KV数据库)</li><li>Vertica (列存储式数据库)</li><li>Aster Data (关系型数据库)</li><li>Greenplum (关系型数据库)</li></ul><p>类似"Sharding"中我们采用的方案，生产环境线上的数据库也往往采用放弃一定的一致性( C ) ，来提高可用性( A )和分区可容忍性( P )。</p><p>如下图：</p><img src="https://pic2.zhimg.com/41d7018aa8fa5b3b0a7f032b38d0234d_b.png" data-rawwidth="1056" data-rawheight="1116" class="origin_image zh-lightbox-thumb" width="1056" data-original="https://pic2.zhimg.com/41d7018aa8fa5b3b0a7f032b38d0234d_r.png"><p>可以看到，由于大多数互联网公司的需求不是要求强一致性( C )， 所以通过放弃一致性，达到更高的可用性( A )和分区可容忍性 ( P )成了目前市面上大多数NoSQL数据库的核心思想。</p><p>在Amazon著名的分布式数据库Dynamo中，就是采用类似的方法："3副本，写入2个成功后就返回成功，剩下的1个副本后续再进行同步"，我们称这种模式叫"最终一致性"</p><p>这方面典型的代表还有：</p><ul><li>Dynamo (KV数据库)</li><li>Voldemort (KV数据库)</li><li>Tokyo Cabinet (KV数据库)</li><li>KAI (KV数据库)</li><li>Cassandra (列存储式数据库)</li><li>CouchDB (文档式数据库)</li><li>SimpleDB (文档式数据库)</li><li>Riak (文档式数据库)</li><li>MooseFS (类GFS分布式文件系统)</li></ul><p>基本上，上面几种情形已经可以涵盖所有分布式系统的情形了。 我们可以看到，系统设计就像穷人家的被子，盖住头和左脚就露出右脚，盖住头和右脚就露出左脚…… 即使你再有钱也不可能将CAP同时100%满足。</p><p>那么问题就来了，有没有可能将CAP同时提升呢？答案是：Sure, ofcourse.</p><p>我们可以通过用更高可靠性的服务器、更可靠的网络设备达到CAP同时提升。</p><div class="highlight"><pre><code class="language-text">例如，假设某银行刚开始采用的是2w块钱的Dell服务器，由于银行业务的特殊性，一致性( P )是首要保证的（任何银行都不愿意看到，同时在ATM上取账户里的100块，都成功了）所以这个服务器可能就是一个单点，可用性( A )十分差劲。银行有钱了，服务器换成IBM大机，CPU都是双路热备份。可用性( A )自然非2w的Dell能比的。
</code></pre></div><p>但还是那句话：</p><div class="highlight"><pre><code class="language-text">就算你再有钱，要找不到一个能盖住双腿和头的被子。
</code></pre></div><h4>BASE &amp; ACID</h4><p>我们知道，数据库的事务有ACID的保证：</p><p>事务机制可以确保数据一致性。</p><p>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p><ul><li>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li><li>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li><li>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执* 行的各个事务之间不能互相干扰。</li><li>持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li></ul><p>后来，随着NoSQL的兴起，技术界又提出了BASE的概念：</p><ul><li><p>Basically Availble --基本可用</p><p>支持分区失败（Sharding碎片划分数据库），出了问题服务仅降级（部分不可用）。</p></li><li><p>Soft-state --软状态/柔性</p><p>事务"Soft state" 可以理解为"无连接"的, 而 "Hard state" 是"面向连接"的。 软状态就是可以有一段时间不同步，异步。</p></li><li><p>Eventual Consistency --最终一致性</p><p>最终数据是一致的就可以了，而不是时时一致。</p></li></ul><p>合起来就是BASE。</p><p>比较有意思的是：在英语里ACID是酸的意思；BASE也有碱的意思。</p><br><br>著作权归作者所有，任何转载请联系作者获得授权。<br>作者：auxten<br>链接：<a href="http://zhuanlan.zhihu.com/auxten/20399316" class="internal">网络编程（六）：CAP原理推导和应用 - 面向工资编程 - 知乎专栏</a><br>来源：知乎<br><img src="https://pic3.zhimg.com/91730ff8713adb3fb80d79dba4beb3de_b.jpg" data-rawwidth="344" data-rawheight="344" class="content_image" width="344"><p>服务端开发群：365534424，本文仅授权51
Reboot相关账号发布。</p></div></div></body></html>